/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const ShabakAPI_BASE_URL = new OpaqueToken('ShabakAPI_BASE_URL');

export interface IActionTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBLDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_notes (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_employeeActionID: number, model_actionTaken: number, model_actionDate: Date, model_attachments: string, model_iD?: number | null | undefined, model_notes?: string | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, actionTBL: ActionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    addNew(actionTBL: ActionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionTBLsClient implements IActionTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<ActionTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_notes (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_employeeActionID: number, model_actionTaken: number, model_actionDate: Date, model_attachments: string, model_iD?: number | null | undefined, model_notes?: string | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/GetByParams?";
        if (model_employeeActionID === undefined || model_employeeActionID === null)
            throw new Error("The parameter 'model_employeeActionID' must be defined and cannot be null.");
        else
            url_ += "model.employeeActionID=" + encodeURIComponent("" + model_employeeActionID) + "&"; 
        if (model_actionTaken === undefined || model_actionTaken === null)
            throw new Error("The parameter 'model_actionTaken' must be defined and cannot be null.");
        else
            url_ += "model.actionTaken=" + encodeURIComponent("" + model_actionTaken) + "&"; 
        if (model_actionDate === undefined || model_actionDate === null)
            throw new Error("The parameter 'model_actionDate' must be defined and cannot be null.");
        else
            url_ += "model.actionDate=" + encodeURIComponent(model_actionDate ? "" + model_actionDate.toJSON() : "") + "&"; 
        if (model_attachments === undefined || model_attachments === null)
            throw new Error("The parameter 'model_attachments' must be defined and cannot be null.");
        else
            url_ += "model.attachments=" + encodeURIComponent("" + model_attachments) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_notes !== undefined)
            url_ += "model.notes=" + encodeURIComponent("" + model_notes) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<ActionTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL[]>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<ActionTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<ActionTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionTBL.fromJS(resultData200, _mappings) : new ActionTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, actionTBL: ActionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    addNew(actionTBL: ActionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNew(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processAddNew(response: HttpResponseBase): Observable<SwaggerResponse<ActionTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionTBL.fromJS(resultData200, _mappings) : new ActionTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTBL>> {
        let url_ = this.baseUrl + "/api/ActionTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<ActionTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionTBL.fromJS(resultData200, _mappings) : new ActionTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IActionTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTypeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_percentageAdd: number, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getActionTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getActionType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, actionType: ActionTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(actionType: ActionTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType>>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionTypesClient implements IActionTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/ActionTypes/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<ActionTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_percentageAdd: number, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/ActionTypes/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_percentageAdd === undefined || model_percentageAdd === null)
            throw new Error("The parameter 'model_percentageAdd' must be defined and cannot be null.");
        else
            url_ += "model.percentageAdd=" + encodeURIComponent("" + model_percentageAdd) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<ActionTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getActionTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType[]>> {
        let url_ = this.baseUrl + "/api/ActionTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionTypes(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionTypes(response: HttpResponseBase): Observable<SwaggerResponse<ActionType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getActionType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType>> {
        let url_ = this.baseUrl + "/api/ActionTypes/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionType(response: HttpResponseBase): Observable<SwaggerResponse<ActionType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionType.fromJS(resultData200, _mappings) : new ActionType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, actionType: ActionTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ActionTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(actionType: ActionTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType>> {
        let url_ = this.baseUrl + "/api/ActionTypes/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(actionType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionType>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<ActionType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionType.fromJS(resultData200, _mappings) : new ActionType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ActionType>> {
        let url_ = this.baseUrl + "/api/ActionTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ActionType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ActionType>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<ActionType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionType.fromJS(resultData200, _mappings) : new ActionType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ActionType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IArchiveTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBLDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_details (optional) 
     * @param model_projectID (optional) 
     * @param model_documentType (optional) 
     * @param model_filePathLink (optional) 
     * @param model_addDate (optional) 
     * @param model_withHardCopy (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_iD?: number | null | undefined, model_details?: string | null | undefined, model_projectID?: number | null | undefined, model_documentType?: number | null | undefined, model_filePathLink?: string | null | undefined, model_addDate?: Date | null | undefined, model_withHardCopy?: boolean | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBLDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_details (optional) 
     * @param model_projectID (optional) 
     * @param model_documentType (optional) 
     * @param model_filePathLink (optional) 
     * @param model_addDate (optional) 
     * @param model_withHardCopy (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_iD?: number | null | undefined, model_details?: string | null | undefined, model_projectID?: number | null | undefined, model_documentType?: number | null | undefined, model_filePathLink?: string | null | undefined, model_addDate?: Date | null | undefined, model_withHardCopy?: boolean | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, archiveTBL: ArchiveTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(archiveTBL: ArchiveTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class ArchiveTBLsClient implements IArchiveTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArchiveTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_details (optional) 
     * @param model_projectID (optional) 
     * @param model_documentType (optional) 
     * @param model_filePathLink (optional) 
     * @param model_addDate (optional) 
     * @param model_withHardCopy (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_iD?: number | null | undefined, model_details?: string | null | undefined, model_projectID?: number | null | undefined, model_documentType?: number | null | undefined, model_filePathLink?: string | null | undefined, model_addDate?: Date | null | undefined, model_withHardCopy?: boolean | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/GetByParams?";
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_details !== undefined)
            url_ += "model.details=" + encodeURIComponent("" + model_details) + "&"; 
        if (model_projectID !== undefined)
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_documentType !== undefined)
            url_ += "model.documentType=" + encodeURIComponent("" + model_documentType) + "&"; 
        if (model_filePathLink !== undefined)
            url_ += "model.filePathLink=" + encodeURIComponent("" + model_filePathLink) + "&"; 
        if (model_addDate !== undefined)
            url_ += "model.addDate=" + encodeURIComponent(model_addDate ? "" + model_addDate.toJSON() : "") + "&"; 
        if (model_withHardCopy !== undefined)
            url_ += "model.withHardCopy=" + encodeURIComponent("" + model_withHardCopy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArchiveTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_details (optional) 
     * @param model_projectID (optional) 
     * @param model_documentType (optional) 
     * @param model_filePathLink (optional) 
     * @param model_addDate (optional) 
     * @param model_withHardCopy (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_iD?: number | null | undefined, model_details?: string | null | undefined, model_projectID?: number | null | undefined, model_documentType?: number | null | undefined, model_filePathLink?: string | null | undefined, model_addDate?: Date | null | undefined, model_withHardCopy?: boolean | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/GetByLike?";
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_details !== undefined)
            url_ += "model.details=" + encodeURIComponent("" + model_details) + "&"; 
        if (model_projectID !== undefined)
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_documentType !== undefined)
            url_ += "model.documentType=" + encodeURIComponent("" + model_documentType) + "&"; 
        if (model_filePathLink !== undefined)
            url_ += "model.filePathLink=" + encodeURIComponent("" + model_filePathLink) + "&"; 
        if (model_addDate !== undefined)
            url_ += "model.addDate=" + encodeURIComponent(model_addDate ? "" + model_addDate.toJSON() : "") + "&"; 
        if (model_withHardCopy !== undefined)
            url_ += "model.withHardCopy=" + encodeURIComponent("" + model_withHardCopy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArchiveTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL[]>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArchiveTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArchiveTBL.fromJS(resultData200, _mappings) : new ArchiveTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, archiveTBL: ArchiveTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(archiveTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(archiveTBL: ArchiveTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(archiveTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArchiveTBL.fromJS(resultData200, _mappings) : new ArchiveTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ArchiveTBL>> {
        let url_ = this.baseUrl + "/api/ArchiveTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ArchiveTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ArchiveTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<ArchiveTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ArchiveTBL.fromJS(resultData200, _mappings) : new ArchiveTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ArchiveTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IContractsChangesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChangeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_originalAmount (optional) 
     * @param model_newAmount (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_projectID: number, model_changedDescription: string, model_iD?: number | null | undefined, model_originalAmount?: number | null | undefined, model_newAmount?: number | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChangeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_originalAmount (optional) 
     * @param model_newAmount (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_projectID: number, model_changedDescription: string, model_iD?: number | null | undefined, model_originalAmount?: number | null | undefined, model_newAmount?: number | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChangeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, contractsChange: ContractsChangeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(contractsChange: ContractsChangeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange>>;
}

@Injectable({
    providedIn: 'root'
})
export class ContractsChangesClient implements IContractsChangesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChangeDTO[]>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChangeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChangeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChangeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChangeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_originalAmount (optional) 
     * @param model_newAmount (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_projectID: number, model_changedDescription: string, model_iD?: number | null | undefined, model_originalAmount?: number | null | undefined, model_newAmount?: number | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChangeDTO[]>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/GetByParams?";
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_changedDescription === undefined || model_changedDescription === null)
            throw new Error("The parameter 'model_changedDescription' must be defined and cannot be null.");
        else
            url_ += "model.changedDescription=" + encodeURIComponent("" + model_changedDescription) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_originalAmount !== undefined)
            url_ += "model.originalAmount=" + encodeURIComponent("" + model_originalAmount) + "&"; 
        if (model_newAmount !== undefined)
            url_ += "model.newAmount=" + encodeURIComponent("" + model_newAmount) + "&"; 
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChangeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChangeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChangeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChangeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_originalAmount (optional) 
     * @param model_newAmount (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_projectID: number, model_changedDescription: string, model_iD?: number | null | undefined, model_originalAmount?: number | null | undefined, model_newAmount?: number | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChangeDTO[]>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/GetByLike?";
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_changedDescription === undefined || model_changedDescription === null)
            throw new Error("The parameter 'model_changedDescription' must be defined and cannot be null.");
        else
            url_ += "model.changedDescription=" + encodeURIComponent("" + model_changedDescription) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_originalAmount !== undefined)
            url_ += "model.originalAmount=" + encodeURIComponent("" + model_originalAmount) + "&"; 
        if (model_newAmount !== undefined)
            url_ += "model.newAmount=" + encodeURIComponent("" + model_newAmount) + "&"; 
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChangeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChangeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChangeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChangeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange[]>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChange[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChange[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChange[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractsChange.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChange[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChange>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChange>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChange>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContractsChange.fromJS(resultData200, _mappings) : new ContractsChange();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChange>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, contractsChange: ContractsChangeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contractsChange);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(contractsChange: ContractsChangeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contractsChange);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChange>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChange>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChange>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContractsChange.fromJS(resultData200, _mappings) : new ContractsChange();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChange>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ContractsChange>> {
        let url_ = this.baseUrl + "/api/ContractsChanges/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ContractsChange>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ContractsChange>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<ContractsChange>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContractsChange.fromJS(resultData200, _mappings) : new ContractsChange();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ContractsChange>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IDeliverableStagesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDeliverableStages(authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStageDTO[]>>;
    /**
     * @param model_deliverableID (optional) 
     * @param model_stageID (optional) 
     * @param model_stageProjectStageID (optional) 
     * @param model_stageProjectProjectID (optional) 
     * @param model_stageProjectStageArName (optional) 
     * @param model_stageProjectStageEnName (optional) 
     * @param model_stageProjectStartDate (optional) 
     * @param model_stageProjectEndDate (optional) 
     * @param model_stageProjectStageBudget (optional) 
     * @param model_stageProjectDeliverableStages (optional) 
     * @param model_stageProjectProjectTBLProjectID (optional) 
     * @param model_stageProjectProjectTBLProjectNumber (optional) 
     * @param model_stageProjectProjectTBLArName (optional) 
     * @param model_stageProjectProjectTBLEnName (optional) 
     * @param model_stageProjectProjectTBLStartDate (optional) 
     * @param model_stageProjectProjectTBLMainContractAmount (optional) 
     * @param model_stageProjectProjectTBLEndDate (optional) 
     * @param model_stageProjectProjectTBLIsActiveProject (optional) 
     * @param model_stageProjectProjectTBLContractsChanges (optional) 
     * @param model_stageProjectProjectTBLOrganizationsProjects (optional) 
     * @param model_stageProjectProjectTBLProjectEmployees (optional) 
     * @param model_stageProjectProjectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamDeliverableStages(model_deliverableArName: string, model_deliverableEnName: string, model_startDate: Date, model_endDate: Date, model_deliverableBudget: number, model_deliverableID?: number | null | undefined, model_stageID?: number | null | undefined, model_stageProjectStageID?: number | null | undefined, model_stageProjectProjectID?: number | null | undefined, model_stageProjectStageArName?: string | null | undefined, model_stageProjectStageEnName?: string | null | undefined, model_stageProjectStartDate?: Date | null | undefined, model_stageProjectEndDate?: Date | null | undefined, model_stageProjectStageBudget?: number | null | undefined, model_stageProjectDeliverableStages?: any[] | null | undefined, model_stageProjectProjectTBLProjectID?: number | null | undefined, model_stageProjectProjectTBLProjectNumber?: string | null | undefined, model_stageProjectProjectTBLArName?: string | null | undefined, model_stageProjectProjectTBLEnName?: string | null | undefined, model_stageProjectProjectTBLStartDate?: Date | null | undefined, model_stageProjectProjectTBLMainContractAmount?: number | null | undefined, model_stageProjectProjectTBLEndDate?: Date | null | undefined, model_stageProjectProjectTBLIsActiveProject?: boolean | null | undefined, model_stageProjectProjectTBLContractsChanges?: any[] | null | undefined, model_stageProjectProjectTBLOrganizationsProjects?: any[] | null | undefined, model_stageProjectProjectTBLProjectEmployees?: any[] | null | undefined, model_stageProjectProjectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStageDTO[]>>;
    /**
     * @param model_deliverableID (optional) 
     * @param model_stageID (optional) 
     * @param model_stageProjectStageID (optional) 
     * @param model_stageProjectProjectID (optional) 
     * @param model_stageProjectStageArName (optional) 
     * @param model_stageProjectStageEnName (optional) 
     * @param model_stageProjectStartDate (optional) 
     * @param model_stageProjectEndDate (optional) 
     * @param model_stageProjectStageBudget (optional) 
     * @param model_stageProjectDeliverableStages (optional) 
     * @param model_stageProjectProjectTBLProjectID (optional) 
     * @param model_stageProjectProjectTBLProjectNumber (optional) 
     * @param model_stageProjectProjectTBLArName (optional) 
     * @param model_stageProjectProjectTBLEnName (optional) 
     * @param model_stageProjectProjectTBLStartDate (optional) 
     * @param model_stageProjectProjectTBLMainContractAmount (optional) 
     * @param model_stageProjectProjectTBLEndDate (optional) 
     * @param model_stageProjectProjectTBLIsActiveProject (optional) 
     * @param model_stageProjectProjectTBLContractsChanges (optional) 
     * @param model_stageProjectProjectTBLOrganizationsProjects (optional) 
     * @param model_stageProjectProjectTBLProjectEmployees (optional) 
     * @param model_stageProjectProjectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeDeliverableStage(model_deliverableArName: string, model_deliverableEnName: string, model_startDate: Date, model_endDate: Date, model_deliverableBudget: number, model_deliverableID?: number | null | undefined, model_stageID?: number | null | undefined, model_stageProjectStageID?: number | null | undefined, model_stageProjectProjectID?: number | null | undefined, model_stageProjectStageArName?: string | null | undefined, model_stageProjectStageEnName?: string | null | undefined, model_stageProjectStartDate?: Date | null | undefined, model_stageProjectEndDate?: Date | null | undefined, model_stageProjectStageBudget?: number | null | undefined, model_stageProjectDeliverableStages?: any[] | null | undefined, model_stageProjectProjectTBLProjectID?: number | null | undefined, model_stageProjectProjectTBLProjectNumber?: string | null | undefined, model_stageProjectProjectTBLArName?: string | null | undefined, model_stageProjectProjectTBLEnName?: string | null | undefined, model_stageProjectProjectTBLStartDate?: Date | null | undefined, model_stageProjectProjectTBLMainContractAmount?: number | null | undefined, model_stageProjectProjectTBLEndDate?: Date | null | undefined, model_stageProjectProjectTBLIsActiveProject?: boolean | null | undefined, model_stageProjectProjectTBLContractsChanges?: any[] | null | undefined, model_stageProjectProjectTBLOrganizationsProjects?: any[] | null | undefined, model_stageProjectProjectTBLProjectEmployees?: any[] | null | undefined, model_stageProjectProjectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStageDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getDeliverableStages(authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getDeliverableStage(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putDeliverableStage(id: number, deliverableStage: DeliverableStageDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postDeliverableStage(deliverableStage: DeliverableStageDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteDeliverableStage(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage>>;
}

@Injectable({
    providedIn: 'root'
})
export class DeliverableStagesClient implements IDeliverableStagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDeliverableStages(authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStageDTO[]>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeliverableStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeliverableStages(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStageDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStageDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDeliverableStages(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStageDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeliverableStageDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStageDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_deliverableID (optional) 
     * @param model_stageID (optional) 
     * @param model_stageProjectStageID (optional) 
     * @param model_stageProjectProjectID (optional) 
     * @param model_stageProjectStageArName (optional) 
     * @param model_stageProjectStageEnName (optional) 
     * @param model_stageProjectStartDate (optional) 
     * @param model_stageProjectEndDate (optional) 
     * @param model_stageProjectStageBudget (optional) 
     * @param model_stageProjectDeliverableStages (optional) 
     * @param model_stageProjectProjectTBLProjectID (optional) 
     * @param model_stageProjectProjectTBLProjectNumber (optional) 
     * @param model_stageProjectProjectTBLArName (optional) 
     * @param model_stageProjectProjectTBLEnName (optional) 
     * @param model_stageProjectProjectTBLStartDate (optional) 
     * @param model_stageProjectProjectTBLMainContractAmount (optional) 
     * @param model_stageProjectProjectTBLEndDate (optional) 
     * @param model_stageProjectProjectTBLIsActiveProject (optional) 
     * @param model_stageProjectProjectTBLContractsChanges (optional) 
     * @param model_stageProjectProjectTBLOrganizationsProjects (optional) 
     * @param model_stageProjectProjectTBLProjectEmployees (optional) 
     * @param model_stageProjectProjectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamDeliverableStages(model_deliverableArName: string, model_deliverableEnName: string, model_startDate: Date, model_endDate: Date, model_deliverableBudget: number, model_deliverableID?: number | null | undefined, model_stageID?: number | null | undefined, model_stageProjectStageID?: number | null | undefined, model_stageProjectProjectID?: number | null | undefined, model_stageProjectStageArName?: string | null | undefined, model_stageProjectStageEnName?: string | null | undefined, model_stageProjectStartDate?: Date | null | undefined, model_stageProjectEndDate?: Date | null | undefined, model_stageProjectStageBudget?: number | null | undefined, model_stageProjectDeliverableStages?: any[] | null | undefined, model_stageProjectProjectTBLProjectID?: number | null | undefined, model_stageProjectProjectTBLProjectNumber?: string | null | undefined, model_stageProjectProjectTBLArName?: string | null | undefined, model_stageProjectProjectTBLEnName?: string | null | undefined, model_stageProjectProjectTBLStartDate?: Date | null | undefined, model_stageProjectProjectTBLMainContractAmount?: number | null | undefined, model_stageProjectProjectTBLEndDate?: Date | null | undefined, model_stageProjectProjectTBLIsActiveProject?: boolean | null | undefined, model_stageProjectProjectTBLContractsChanges?: any[] | null | undefined, model_stageProjectProjectTBLOrganizationsProjects?: any[] | null | undefined, model_stageProjectProjectTBLProjectEmployees?: any[] | null | undefined, model_stageProjectProjectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStageDTO[]>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/GetByParam?";
        if (model_deliverableArName === undefined || model_deliverableArName === null)
            throw new Error("The parameter 'model_deliverableArName' must be defined and cannot be null.");
        else
            url_ += "model.deliverableArName=" + encodeURIComponent("" + model_deliverableArName) + "&"; 
        if (model_deliverableEnName === undefined || model_deliverableEnName === null)
            throw new Error("The parameter 'model_deliverableEnName' must be defined and cannot be null.");
        else
            url_ += "model.deliverableEnName=" + encodeURIComponent("" + model_deliverableEnName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_deliverableBudget === undefined || model_deliverableBudget === null)
            throw new Error("The parameter 'model_deliverableBudget' must be defined and cannot be null.");
        else
            url_ += "model.deliverableBudget=" + encodeURIComponent("" + model_deliverableBudget) + "&"; 
        if (model_deliverableID !== undefined)
            url_ += "model.deliverableID=" + encodeURIComponent("" + model_deliverableID) + "&"; 
        if (model_stageID !== undefined)
            url_ += "model.stageID=" + encodeURIComponent("" + model_stageID) + "&"; 
        if (model_stageProjectStageID !== undefined)
            url_ += "model.stageProjectStageID=" + encodeURIComponent("" + model_stageProjectStageID) + "&"; 
        if (model_stageProjectProjectID !== undefined)
            url_ += "model.stageProjectProjectID=" + encodeURIComponent("" + model_stageProjectProjectID) + "&"; 
        if (model_stageProjectStageArName !== undefined)
            url_ += "model.stageProjectStageArName=" + encodeURIComponent("" + model_stageProjectStageArName) + "&"; 
        if (model_stageProjectStageEnName !== undefined)
            url_ += "model.stageProjectStageEnName=" + encodeURIComponent("" + model_stageProjectStageEnName) + "&"; 
        if (model_stageProjectStartDate !== undefined)
            url_ += "model.stageProjectStartDate=" + encodeURIComponent(model_stageProjectStartDate ? "" + model_stageProjectStartDate.toJSON() : "") + "&"; 
        if (model_stageProjectEndDate !== undefined)
            url_ += "model.stageProjectEndDate=" + encodeURIComponent(model_stageProjectEndDate ? "" + model_stageProjectEndDate.toJSON() : "") + "&"; 
        if (model_stageProjectStageBudget !== undefined)
            url_ += "model.stageProjectStageBudget=" + encodeURIComponent("" + model_stageProjectStageBudget) + "&"; 
        if (model_stageProjectDeliverableStages !== undefined)
            model_stageProjectDeliverableStages && model_stageProjectDeliverableStages.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectDeliverableStages[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLProjectID !== undefined)
            url_ += "model.stageProjectProjectTBLProjectID=" + encodeURIComponent("" + model_stageProjectProjectTBLProjectID) + "&"; 
        if (model_stageProjectProjectTBLProjectNumber !== undefined)
            url_ += "model.stageProjectProjectTBLProjectNumber=" + encodeURIComponent("" + model_stageProjectProjectTBLProjectNumber) + "&"; 
        if (model_stageProjectProjectTBLArName !== undefined)
            url_ += "model.stageProjectProjectTBLArName=" + encodeURIComponent("" + model_stageProjectProjectTBLArName) + "&"; 
        if (model_stageProjectProjectTBLEnName !== undefined)
            url_ += "model.stageProjectProjectTBLEnName=" + encodeURIComponent("" + model_stageProjectProjectTBLEnName) + "&"; 
        if (model_stageProjectProjectTBLStartDate !== undefined)
            url_ += "model.stageProjectProjectTBLStartDate=" + encodeURIComponent(model_stageProjectProjectTBLStartDate ? "" + model_stageProjectProjectTBLStartDate.toJSON() : "") + "&"; 
        if (model_stageProjectProjectTBLMainContractAmount !== undefined)
            url_ += "model.stageProjectProjectTBLMainContractAmount=" + encodeURIComponent("" + model_stageProjectProjectTBLMainContractAmount) + "&"; 
        if (model_stageProjectProjectTBLEndDate !== undefined)
            url_ += "model.stageProjectProjectTBLEndDate=" + encodeURIComponent(model_stageProjectProjectTBLEndDate ? "" + model_stageProjectProjectTBLEndDate.toJSON() : "") + "&"; 
        if (model_stageProjectProjectTBLIsActiveProject !== undefined)
            url_ += "model.stageProjectProjectTBLIsActiveProject=" + encodeURIComponent("" + model_stageProjectProjectTBLIsActiveProject) + "&"; 
        if (model_stageProjectProjectTBLContractsChanges !== undefined)
            model_stageProjectProjectTBLContractsChanges && model_stageProjectProjectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLOrganizationsProjects !== undefined)
            model_stageProjectProjectTBLOrganizationsProjects && model_stageProjectProjectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLProjectEmployees !== undefined)
            model_stageProjectProjectTBLProjectEmployees && model_stageProjectProjectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLStageProjects !== undefined)
            model_stageProjectProjectTBLStageProjects && model_stageProjectProjectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamDeliverableStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamDeliverableStages(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStageDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStageDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamDeliverableStages(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStageDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeliverableStageDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStageDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_deliverableID (optional) 
     * @param model_stageID (optional) 
     * @param model_stageProjectStageID (optional) 
     * @param model_stageProjectProjectID (optional) 
     * @param model_stageProjectStageArName (optional) 
     * @param model_stageProjectStageEnName (optional) 
     * @param model_stageProjectStartDate (optional) 
     * @param model_stageProjectEndDate (optional) 
     * @param model_stageProjectStageBudget (optional) 
     * @param model_stageProjectDeliverableStages (optional) 
     * @param model_stageProjectProjectTBLProjectID (optional) 
     * @param model_stageProjectProjectTBLProjectNumber (optional) 
     * @param model_stageProjectProjectTBLArName (optional) 
     * @param model_stageProjectProjectTBLEnName (optional) 
     * @param model_stageProjectProjectTBLStartDate (optional) 
     * @param model_stageProjectProjectTBLMainContractAmount (optional) 
     * @param model_stageProjectProjectTBLEndDate (optional) 
     * @param model_stageProjectProjectTBLIsActiveProject (optional) 
     * @param model_stageProjectProjectTBLContractsChanges (optional) 
     * @param model_stageProjectProjectTBLOrganizationsProjects (optional) 
     * @param model_stageProjectProjectTBLProjectEmployees (optional) 
     * @param model_stageProjectProjectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeDeliverableStage(model_deliverableArName: string, model_deliverableEnName: string, model_startDate: Date, model_endDate: Date, model_deliverableBudget: number, model_deliverableID?: number | null | undefined, model_stageID?: number | null | undefined, model_stageProjectStageID?: number | null | undefined, model_stageProjectProjectID?: number | null | undefined, model_stageProjectStageArName?: string | null | undefined, model_stageProjectStageEnName?: string | null | undefined, model_stageProjectStartDate?: Date | null | undefined, model_stageProjectEndDate?: Date | null | undefined, model_stageProjectStageBudget?: number | null | undefined, model_stageProjectDeliverableStages?: any[] | null | undefined, model_stageProjectProjectTBLProjectID?: number | null | undefined, model_stageProjectProjectTBLProjectNumber?: string | null | undefined, model_stageProjectProjectTBLArName?: string | null | undefined, model_stageProjectProjectTBLEnName?: string | null | undefined, model_stageProjectProjectTBLStartDate?: Date | null | undefined, model_stageProjectProjectTBLMainContractAmount?: number | null | undefined, model_stageProjectProjectTBLEndDate?: Date | null | undefined, model_stageProjectProjectTBLIsActiveProject?: boolean | null | undefined, model_stageProjectProjectTBLContractsChanges?: any[] | null | undefined, model_stageProjectProjectTBLOrganizationsProjects?: any[] | null | undefined, model_stageProjectProjectTBLProjectEmployees?: any[] | null | undefined, model_stageProjectProjectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStageDTO[]>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/GetByLike?";
        if (model_deliverableArName === undefined || model_deliverableArName === null)
            throw new Error("The parameter 'model_deliverableArName' must be defined and cannot be null.");
        else
            url_ += "model.deliverableArName=" + encodeURIComponent("" + model_deliverableArName) + "&"; 
        if (model_deliverableEnName === undefined || model_deliverableEnName === null)
            throw new Error("The parameter 'model_deliverableEnName' must be defined and cannot be null.");
        else
            url_ += "model.deliverableEnName=" + encodeURIComponent("" + model_deliverableEnName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_deliverableBudget === undefined || model_deliverableBudget === null)
            throw new Error("The parameter 'model_deliverableBudget' must be defined and cannot be null.");
        else
            url_ += "model.deliverableBudget=" + encodeURIComponent("" + model_deliverableBudget) + "&"; 
        if (model_deliverableID !== undefined)
            url_ += "model.deliverableID=" + encodeURIComponent("" + model_deliverableID) + "&"; 
        if (model_stageID !== undefined)
            url_ += "model.stageID=" + encodeURIComponent("" + model_stageID) + "&"; 
        if (model_stageProjectStageID !== undefined)
            url_ += "model.stageProjectStageID=" + encodeURIComponent("" + model_stageProjectStageID) + "&"; 
        if (model_stageProjectProjectID !== undefined)
            url_ += "model.stageProjectProjectID=" + encodeURIComponent("" + model_stageProjectProjectID) + "&"; 
        if (model_stageProjectStageArName !== undefined)
            url_ += "model.stageProjectStageArName=" + encodeURIComponent("" + model_stageProjectStageArName) + "&"; 
        if (model_stageProjectStageEnName !== undefined)
            url_ += "model.stageProjectStageEnName=" + encodeURIComponent("" + model_stageProjectStageEnName) + "&"; 
        if (model_stageProjectStartDate !== undefined)
            url_ += "model.stageProjectStartDate=" + encodeURIComponent(model_stageProjectStartDate ? "" + model_stageProjectStartDate.toJSON() : "") + "&"; 
        if (model_stageProjectEndDate !== undefined)
            url_ += "model.stageProjectEndDate=" + encodeURIComponent(model_stageProjectEndDate ? "" + model_stageProjectEndDate.toJSON() : "") + "&"; 
        if (model_stageProjectStageBudget !== undefined)
            url_ += "model.stageProjectStageBudget=" + encodeURIComponent("" + model_stageProjectStageBudget) + "&"; 
        if (model_stageProjectDeliverableStages !== undefined)
            model_stageProjectDeliverableStages && model_stageProjectDeliverableStages.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectDeliverableStages[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLProjectID !== undefined)
            url_ += "model.stageProjectProjectTBLProjectID=" + encodeURIComponent("" + model_stageProjectProjectTBLProjectID) + "&"; 
        if (model_stageProjectProjectTBLProjectNumber !== undefined)
            url_ += "model.stageProjectProjectTBLProjectNumber=" + encodeURIComponent("" + model_stageProjectProjectTBLProjectNumber) + "&"; 
        if (model_stageProjectProjectTBLArName !== undefined)
            url_ += "model.stageProjectProjectTBLArName=" + encodeURIComponent("" + model_stageProjectProjectTBLArName) + "&"; 
        if (model_stageProjectProjectTBLEnName !== undefined)
            url_ += "model.stageProjectProjectTBLEnName=" + encodeURIComponent("" + model_stageProjectProjectTBLEnName) + "&"; 
        if (model_stageProjectProjectTBLStartDate !== undefined)
            url_ += "model.stageProjectProjectTBLStartDate=" + encodeURIComponent(model_stageProjectProjectTBLStartDate ? "" + model_stageProjectProjectTBLStartDate.toJSON() : "") + "&"; 
        if (model_stageProjectProjectTBLMainContractAmount !== undefined)
            url_ += "model.stageProjectProjectTBLMainContractAmount=" + encodeURIComponent("" + model_stageProjectProjectTBLMainContractAmount) + "&"; 
        if (model_stageProjectProjectTBLEndDate !== undefined)
            url_ += "model.stageProjectProjectTBLEndDate=" + encodeURIComponent(model_stageProjectProjectTBLEndDate ? "" + model_stageProjectProjectTBLEndDate.toJSON() : "") + "&"; 
        if (model_stageProjectProjectTBLIsActiveProject !== undefined)
            url_ += "model.stageProjectProjectTBLIsActiveProject=" + encodeURIComponent("" + model_stageProjectProjectTBLIsActiveProject) + "&"; 
        if (model_stageProjectProjectTBLContractsChanges !== undefined)
            model_stageProjectProjectTBLContractsChanges && model_stageProjectProjectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLOrganizationsProjects !== undefined)
            model_stageProjectProjectTBLOrganizationsProjects && model_stageProjectProjectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLProjectEmployees !== undefined)
            model_stageProjectProjectTBLProjectEmployees && model_stageProjectProjectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_stageProjectProjectTBLStageProjects !== undefined)
            model_stageProjectProjectTBLStageProjects && model_stageProjectProjectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.stageProjectProjectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectlikeDeliverableStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectlikeDeliverableStage(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStageDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStageDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectlikeDeliverableStage(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStageDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeliverableStageDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStageDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getDeliverableStages(authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage[]>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeliverableStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeliverableStages(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStage[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStage[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeliverableStages(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStage[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeliverableStage.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStage[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getDeliverableStage(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeliverableStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeliverableStage(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStage>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStage>>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeliverableStage(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStage>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeliverableStage.fromJS(resultData200, _mappings) : new DeliverableStage();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStage>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putDeliverableStage(id: number, deliverableStage: DeliverableStageDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deliverableStage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutDeliverableStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutDeliverableStage(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutDeliverableStage(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postDeliverableStage(deliverableStage: DeliverableStageDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deliverableStage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDeliverableStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDeliverableStage(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStage>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStage>>><any>_observableThrow(response_);
        }));
    }

    protected processPostDeliverableStage(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStage>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeliverableStage.fromJS(resultData200, _mappings) : new DeliverableStage();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStage>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteDeliverableStage(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DeliverableStage>> {
        let url_ = this.baseUrl + "/api/DeliverableStages/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeliverableStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeliverableStage(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DeliverableStage>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DeliverableStage>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeliverableStage(response: HttpResponseBase): Observable<SwaggerResponse<DeliverableStage>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeliverableStage.fromJS(resultData200, _mappings) : new DeliverableStage();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DeliverableStage>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IDivisionTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBLDTO[]>>;
    /**
     * @param model_divisionID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_divisionID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBLDTO[]>>;
    /**
     * @param model_divisionID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_divisionID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, divisionTBL: DivisionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postDivisionTBL(divisionTBL: DivisionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteDivisionTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class DivisionTBLsClient implements IDivisionTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DivisionTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DivisionTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<DivisionTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DivisionTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DivisionTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_divisionID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_divisionID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_divisionID !== undefined)
            url_ += "model.divisionID=" + encodeURIComponent("" + model_divisionID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DivisionTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DivisionTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<DivisionTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DivisionTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DivisionTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_divisionID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_divisionID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/GetByLike?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_divisionID !== undefined)
            url_ += "model.divisionID=" + encodeURIComponent("" + model_divisionID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DivisionTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DivisionTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<DivisionTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DivisionTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DivisionTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBL[]>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DivisionTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DivisionTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<DivisionTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DivisionTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DivisionTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, divisionTBL: DivisionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(divisionTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postDivisionTBL(divisionTBL: DivisionTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBL>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(divisionTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDivisionTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDivisionTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DivisionTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DivisionTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processPostDivisionTBL(response: HttpResponseBase): Observable<SwaggerResponse<DivisionTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DivisionTBL.fromJS(resultData200, _mappings) : new DivisionTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DivisionTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteDivisionTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DivisionTBL>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDivisionTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDivisionTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DivisionTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DivisionTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDivisionTBL(response: HttpResponseBase): Observable<SwaggerResponse<DivisionTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DivisionTBL.fromJS(resultData200, _mappings) : new DivisionTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DivisionTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IDocumentTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, documentType: DocumentTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(documentType: DocumentTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType>>;
}

@Injectable({
    providedIn: 'root'
})
export class DocumentTypesClient implements IDocumentTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/DocumentTypes/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DocumentTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DocumentTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<DocumentTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DocumentTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType[]>> {
        let url_ = this.baseUrl + "/api/DocumentTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DocumentType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DocumentType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<DocumentType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DocumentType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType>> {
        let url_ = this.baseUrl + "/api/DocumentTypes/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DocumentType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DocumentType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<DocumentType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200, _mappings) : new DocumentType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DocumentType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, documentType: DocumentTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/DocumentTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(documentType: DocumentTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType>> {
        let url_ = this.baseUrl + "/api/DocumentTypes/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DocumentType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DocumentType>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<DocumentType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200, _mappings) : new DocumentType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DocumentType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<DocumentType>> {
        let url_ = this.baseUrl + "/api/DocumentTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<DocumentType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<DocumentType>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<DocumentType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200, _mappings) : new DocumentType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<DocumentType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IEmployeeOffTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>;
    /**
     * @param model_employeeOffTypeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_employeeOffTypeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>;
    /**
     * @param model_employeeOffTypeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_employeeOffTypeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeOffTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeOffType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putEmployeeOffType(id: number, employeeOffType: EmployeeOffTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postEmployeeOffType(employeeOffType: EmployeeOffTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteEmployeeOffType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType>>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeOffTypesClient implements IEmployeeOffTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeOffTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_employeeOffTypeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_employeeOffTypeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_employeeOffTypeID !== undefined)
            url_ += "model.employeeOffTypeID=" + encodeURIComponent("" + model_employeeOffTypeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeOffTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_employeeOffTypeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_employeeOffTypeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/GetByLike?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_employeeOffTypeID !== undefined)
            url_ += "model.employeeOffTypeID=" + encodeURIComponent("" + model_employeeOffTypeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeOffTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeOffTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType[]>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeOffTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeOffTypes(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeOffTypes(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeOffType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeOffType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeOffType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeOffType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeOffType(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeOffType.fromJS(resultData200, _mappings) : new EmployeeOffType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putEmployeeOffType(id: number, employeeOffType: EmployeeOffTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeOffType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutEmployeeOffType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutEmployeeOffType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutEmployeeOffType(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postEmployeeOffType(employeeOffType: EmployeeOffTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeOffType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostEmployeeOffType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostEmployeeOffType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffType>>><any>_observableThrow(response_);
        }));
    }

    protected processPostEmployeeOffType(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeOffType.fromJS(resultData200, _mappings) : new EmployeeOffType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteEmployeeOffType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeOffType>> {
        let url_ = this.baseUrl + "/api/EmployeeOffTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeOffType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeOffType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeOffType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeOffType>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeOffType(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeOffType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeOffType.fromJS(resultData200, _mappings) : new EmployeeOffType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeOffType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IEmployeeTasksClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTaskDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_taskID: number, model_empID: number, model_roleInTask: number, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTaskDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeTasks(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, employeeTask: EmployeeTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(employeeTask: EmployeeTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask>>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeTasksClient implements IEmployeeTasksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTaskDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTaskDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTaskDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTaskDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTaskDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTaskDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_taskID: number, model_empID: number, model_roleInTask: number, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTaskDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/GetByParams?";
        if (model_taskID === undefined || model_taskID === null)
            throw new Error("The parameter 'model_taskID' must be defined and cannot be null.");
        else
            url_ += "model.taskID=" + encodeURIComponent("" + model_taskID) + "&"; 
        if (model_empID === undefined || model_empID === null)
            throw new Error("The parameter 'model_empID' must be defined and cannot be null.");
        else
            url_ += "model.empID=" + encodeURIComponent("" + model_empID) + "&"; 
        if (model_roleInTask === undefined || model_roleInTask === null)
            throw new Error("The parameter 'model_roleInTask' must be defined and cannot be null.");
        else
            url_ += "model.roleInTask=" + encodeURIComponent("" + model_roleInTask) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTaskDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTaskDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTaskDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTaskDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTaskDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeTasks(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTasks(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTask[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTask[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTasks(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTask[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTask.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTask[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTask>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTask>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTask>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeTask.fromJS(resultData200, _mappings) : new EmployeeTask();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTask>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, employeeTask: EmployeeTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeTask);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(employeeTask: EmployeeTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeTask);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTask>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTask>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTask>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeTask.fromJS(resultData200, _mappings) : new EmployeeTask();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTask>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTask>> {
        let url_ = this.baseUrl + "/api/EmployeeTasks/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTask>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTask>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTask>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeTask.fromJS(resultData200, _mappings) : new EmployeeTask();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTask>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IEmployeeTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBLDTO[]>>;
    /**
     * @param model_employeeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_startDate: Date, model_bithDate: Date, model_nationalityID: number, model_divisionID: number, model_jobTitleID: number, model_phoneNumber: string, model_isActiveStatus: boolean, model_emailAddress: string, model_offDate: Date, model_offTypeID: number, model_employeeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBLDTO[]>>;
    /**
     * @param model_employeeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_startDate: Date, model_bithDate: Date, model_nationalityID: number, model_divisionID: number, model_jobTitleID: number, model_phoneNumber: string, model_isActiveStatus: boolean, model_emailAddress: string, model_offDate: Date, model_offTypeID: number, model_employeeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putEmployeeTBL(id: number, employeeTBL: EmployeeTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postEmployeeTBL(employeeTBL: EmployeeTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteEmployeeTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeTBLsClient implements IEmployeeTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_employeeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_startDate: Date, model_bithDate: Date, model_nationalityID: number, model_divisionID: number, model_jobTitleID: number, model_phoneNumber: string, model_isActiveStatus: boolean, model_emailAddress: string, model_offDate: Date, model_offTypeID: number, model_employeeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_bithDate === undefined || model_bithDate === null)
            throw new Error("The parameter 'model_bithDate' must be defined and cannot be null.");
        else
            url_ += "model.bithDate=" + encodeURIComponent(model_bithDate ? "" + model_bithDate.toJSON() : "") + "&"; 
        if (model_nationalityID === undefined || model_nationalityID === null)
            throw new Error("The parameter 'model_nationalityID' must be defined and cannot be null.");
        else
            url_ += "model.nationalityID=" + encodeURIComponent("" + model_nationalityID) + "&"; 
        if (model_divisionID === undefined || model_divisionID === null)
            throw new Error("The parameter 'model_divisionID' must be defined and cannot be null.");
        else
            url_ += "model.divisionID=" + encodeURIComponent("" + model_divisionID) + "&"; 
        if (model_jobTitleID === undefined || model_jobTitleID === null)
            throw new Error("The parameter 'model_jobTitleID' must be defined and cannot be null.");
        else
            url_ += "model.jobTitleID=" + encodeURIComponent("" + model_jobTitleID) + "&"; 
        if (model_phoneNumber === undefined || model_phoneNumber === null)
            throw new Error("The parameter 'model_phoneNumber' must be defined and cannot be null.");
        else
            url_ += "model.phoneNumber=" + encodeURIComponent("" + model_phoneNumber) + "&"; 
        if (model_isActiveStatus === undefined || model_isActiveStatus === null)
            throw new Error("The parameter 'model_isActiveStatus' must be defined and cannot be null.");
        else
            url_ += "model.isActiveStatus=" + encodeURIComponent("" + model_isActiveStatus) + "&"; 
        if (model_emailAddress === undefined || model_emailAddress === null)
            throw new Error("The parameter 'model_emailAddress' must be defined and cannot be null.");
        else
            url_ += "model.emailAddress=" + encodeURIComponent("" + model_emailAddress) + "&"; 
        if (model_offDate === undefined || model_offDate === null)
            throw new Error("The parameter 'model_offDate' must be defined and cannot be null.");
        else
            url_ += "model.offDate=" + encodeURIComponent(model_offDate ? "" + model_offDate.toJSON() : "") + "&"; 
        if (model_offTypeID === undefined || model_offTypeID === null)
            throw new Error("The parameter 'model_offTypeID' must be defined and cannot be null.");
        else
            url_ += "model.offTypeID=" + encodeURIComponent("" + model_offTypeID) + "&"; 
        if (model_employeeID !== undefined)
            url_ += "model.employeeID=" + encodeURIComponent("" + model_employeeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_employeeID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_startDate: Date, model_bithDate: Date, model_nationalityID: number, model_divisionID: number, model_jobTitleID: number, model_phoneNumber: string, model_isActiveStatus: boolean, model_emailAddress: string, model_offDate: Date, model_offTypeID: number, model_employeeID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/GetByLike?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_bithDate === undefined || model_bithDate === null)
            throw new Error("The parameter 'model_bithDate' must be defined and cannot be null.");
        else
            url_ += "model.bithDate=" + encodeURIComponent(model_bithDate ? "" + model_bithDate.toJSON() : "") + "&"; 
        if (model_nationalityID === undefined || model_nationalityID === null)
            throw new Error("The parameter 'model_nationalityID' must be defined and cannot be null.");
        else
            url_ += "model.nationalityID=" + encodeURIComponent("" + model_nationalityID) + "&"; 
        if (model_divisionID === undefined || model_divisionID === null)
            throw new Error("The parameter 'model_divisionID' must be defined and cannot be null.");
        else
            url_ += "model.divisionID=" + encodeURIComponent("" + model_divisionID) + "&"; 
        if (model_jobTitleID === undefined || model_jobTitleID === null)
            throw new Error("The parameter 'model_jobTitleID' must be defined and cannot be null.");
        else
            url_ += "model.jobTitleID=" + encodeURIComponent("" + model_jobTitleID) + "&"; 
        if (model_phoneNumber === undefined || model_phoneNumber === null)
            throw new Error("The parameter 'model_phoneNumber' must be defined and cannot be null.");
        else
            url_ += "model.phoneNumber=" + encodeURIComponent("" + model_phoneNumber) + "&"; 
        if (model_isActiveStatus === undefined || model_isActiveStatus === null)
            throw new Error("The parameter 'model_isActiveStatus' must be defined and cannot be null.");
        else
            url_ += "model.isActiveStatus=" + encodeURIComponent("" + model_isActiveStatus) + "&"; 
        if (model_emailAddress === undefined || model_emailAddress === null)
            throw new Error("The parameter 'model_emailAddress' must be defined and cannot be null.");
        else
            url_ += "model.emailAddress=" + encodeURIComponent("" + model_emailAddress) + "&"; 
        if (model_offDate === undefined || model_offDate === null)
            throw new Error("The parameter 'model_offDate' must be defined and cannot be null.");
        else
            url_ += "model.offDate=" + encodeURIComponent(model_offDate ? "" + model_offDate.toJSON() : "") + "&"; 
        if (model_offTypeID === undefined || model_offTypeID === null)
            throw new Error("The parameter 'model_offTypeID' must be defined and cannot be null.");
        else
            url_ += "model.offTypeID=" + encodeURIComponent("" + model_offTypeID) + "&"; 
        if (model_employeeID !== undefined)
            url_ += "model.employeeID=" + encodeURIComponent("" + model_employeeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL[]>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTBLs(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getEmployeeTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTBL(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeTBL.fromJS(resultData200, _mappings) : new EmployeeTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putEmployeeTBL(id: number, employeeTBL: EmployeeTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutEmployeeTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutEmployeeTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutEmployeeTBL(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postEmployeeTBL(employeeTBL: EmployeeTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostEmployeeTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostEmployeeTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processPostEmployeeTBL(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeTBL.fromJS(resultData200, _mappings) : new EmployeeTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteEmployeeTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EmployeeTBL>> {
        let url_ = this.baseUrl + "/api/EmployeeTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployeeTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployeeTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EmployeeTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EmployeeTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEmployeeTBL(response: HttpResponseBase): Observable<SwaggerResponse<EmployeeTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeTBL.fromJS(resultData200, _mappings) : new EmployeeTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EmployeeTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IEventTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EventTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<EventType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EventType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, eventType: EventTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(eventType: EventTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EventType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EventType>>;
}

@Injectable({
    providedIn: 'root'
})
export class EventTypesClient implements IEventTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<EventTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/EventTypes/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EventTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EventTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<EventTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EventTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<EventType[]>> {
        let url_ = this.baseUrl + "/api/EventTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EventType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EventType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<EventType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EventType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EventType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EventType>> {
        let url_ = this.baseUrl + "/api/EventTypes/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EventType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EventType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<EventType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventType.fromJS(resultData200, _mappings) : new EventType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EventType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, eventType: EventTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/EventTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(eventType: EventTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<EventType>> {
        let url_ = this.baseUrl + "/api/EventTypes/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EventType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EventType>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<EventType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventType.fromJS(resultData200, _mappings) : new EventType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EventType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<EventType>> {
        let url_ = this.baseUrl + "/api/EventTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<EventType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<EventType>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<EventType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventType.fromJS(resultData200, _mappings) : new EventType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<EventType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IFollowUpDocumentsCirclesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>;
    /**
     * @param model_archiveID (optional) 
     * @param model_eventDatetime (optional) 
     * @param model_empID (optional) 
     * @param model_eventType (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_archiveID?: number | null | undefined, model_eventDatetime?: Date | null | undefined, model_empID?: number | null | undefined, model_eventType?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, followUpDocumentsCircle: FollowUpDocumentsCircleDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(followUpDocumentsCircle: FollowUpDocumentsCircleDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle>>;
}

@Injectable({
    providedIn: 'root'
})
export class FollowUpDocumentsCirclesClient implements IFollowUpDocumentsCirclesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FollowUpDocumentsCircleDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_archiveID (optional) 
     * @param model_eventDatetime (optional) 
     * @param model_empID (optional) 
     * @param model_eventType (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_archiveID?: number | null | undefined, model_eventDatetime?: Date | null | undefined, model_empID?: number | null | undefined, model_eventType?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/GetByParams?";
        if (model_archiveID !== undefined)
            url_ += "model.archiveID=" + encodeURIComponent("" + model_archiveID) + "&"; 
        if (model_eventDatetime !== undefined)
            url_ += "model.eventDatetime=" + encodeURIComponent(model_eventDatetime ? "" + model_eventDatetime.toJSON() : "") + "&"; 
        if (model_empID !== undefined)
            url_ += "model.empID=" + encodeURIComponent("" + model_empID) + "&"; 
        if (model_eventType !== undefined)
            url_ += "model.eventType=" + encodeURIComponent("" + model_eventType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<FollowUpDocumentsCircleDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FollowUpDocumentsCircleDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FollowUpDocumentsCircleDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle[]>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<FollowUpDocumentsCircle[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<FollowUpDocumentsCircle[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<FollowUpDocumentsCircle[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FollowUpDocumentsCircle.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FollowUpDocumentsCircle[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<FollowUpDocumentsCircle>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<FollowUpDocumentsCircle>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<FollowUpDocumentsCircle>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FollowUpDocumentsCircle.fromJS(resultData200, _mappings) : new FollowUpDocumentsCircle();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FollowUpDocumentsCircle>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, followUpDocumentsCircle: FollowUpDocumentsCircleDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(followUpDocumentsCircle);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(followUpDocumentsCircle: FollowUpDocumentsCircleDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(followUpDocumentsCircle);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<FollowUpDocumentsCircle>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<FollowUpDocumentsCircle>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<FollowUpDocumentsCircle>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FollowUpDocumentsCircle.fromJS(resultData200, _mappings) : new FollowUpDocumentsCircle();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FollowUpDocumentsCircle>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<FollowUpDocumentsCircle>> {
        let url_ = this.baseUrl + "/api/FollowUpDocumentsCircles/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<FollowUpDocumentsCircle>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<FollowUpDocumentsCircle>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<FollowUpDocumentsCircle>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FollowUpDocumentsCircle.fromJS(resultData200, _mappings) : new FollowUpDocumentsCircle();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FollowUpDocumentsCircle>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IInvoicesTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoicesTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postInvoicesTBL(invoicesTBL: InvoicesTBL, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoicesTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putInvoicesTBL(id: number, invoicesTBL: InvoicesTBL, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteInvoicesTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class InvoicesTBLsClient implements IInvoicesTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoicesTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL[]>> {
        let url_ = this.baseUrl + "/api/InvoicesTBLs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoicesTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoicesTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoicesTBLs(response: HttpResponseBase): Observable<SwaggerResponse<InvoicesTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoicesTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoicesTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postInvoicesTBL(invoicesTBL: InvoicesTBL, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL>> {
        let url_ = this.baseUrl + "/api/InvoicesTBLs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoicesTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostInvoicesTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostInvoicesTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoicesTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoicesTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processPostInvoicesTBL(response: HttpResponseBase): Observable<SwaggerResponse<InvoicesTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoicesTBL.fromJS(resultData200, _mappings) : new InvoicesTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoicesTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoicesTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL>> {
        let url_ = this.baseUrl + "/api/InvoicesTBLs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoicesTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoicesTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoicesTBL(response: HttpResponseBase): Observable<SwaggerResponse<InvoicesTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoicesTBL.fromJS(resultData200, _mappings) : new InvoicesTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoicesTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putInvoicesTBL(id: number, invoicesTBL: InvoicesTBL, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/InvoicesTBLs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoicesTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutInvoicesTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutInvoicesTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutInvoicesTBL(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteInvoicesTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoicesTBL>> {
        let url_ = this.baseUrl + "/api/InvoicesTBLs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoicesTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoicesTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoicesTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoicesTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvoicesTBL(response: HttpResponseBase): Observable<SwaggerResponse<InvoicesTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoicesTBL.fromJS(resultData200, _mappings) : new InvoicesTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoicesTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IInvoiceTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoiceTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postInvoiceType(invoiceType: InvoiceType, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoiceType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putInvoiceType(id: number, invoiceType: InvoiceType, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteInvoiceType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType>>;
}

@Injectable({
    providedIn: 'root'
})
export class InvoiceTypesClient implements IInvoiceTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoiceTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType[]>> {
        let url_ = this.baseUrl + "/api/InvoiceTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceTypes(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoiceType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoiceType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceTypes(response: HttpResponseBase): Observable<SwaggerResponse<InvoiceType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoiceType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postInvoiceType(invoiceType: InvoiceType, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType>> {
        let url_ = this.baseUrl + "/api/InvoiceTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoiceType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostInvoiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostInvoiceType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoiceType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoiceType>>><any>_observableThrow(response_);
        }));
    }

    protected processPostInvoiceType(response: HttpResponseBase): Observable<SwaggerResponse<InvoiceType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200, _mappings) : new InvoiceType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoiceType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getInvoiceType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType>> {
        let url_ = this.baseUrl + "/api/InvoiceTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoiceType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoiceType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceType(response: HttpResponseBase): Observable<SwaggerResponse<InvoiceType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200, _mappings) : new InvoiceType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoiceType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putInvoiceType(id: number, invoiceType: InvoiceType, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/InvoiceTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoiceType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutInvoiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutInvoiceType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutInvoiceType(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteInvoiceType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<InvoiceType>> {
        let url_ = this.baseUrl + "/api/InvoiceTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoiceType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<InvoiceType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<InvoiceType>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvoiceType(response: HttpResponseBase): Observable<SwaggerResponse<InvoiceType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200, _mappings) : new InvoiceType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<InvoiceType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IJobTitleTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBLDTO[]>>;
    /**
     * @param model_jobTitleID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_jobTitleID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBLDTO[]>>;
    /**
     * @param model_jobTitleID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_jobTitleID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getJobTitleTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getJobTitleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putJobTitleTBL(id: number, jobTitleTBL: JobTitleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postJobTitleTBL(jobTitleTBL: JobTitleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteJobTitleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class JobTitleTBLsClient implements IJobTitleTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobTitleTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_jobTitleID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_jobTitleID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_jobTitleID !== undefined)
            url_ += "model.jobTitleID=" + encodeURIComponent("" + model_jobTitleID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobTitleTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_jobTitleID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_jobTitleID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/GetByLike?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_jobTitleID !== undefined)
            url_ += "model.jobTitleID=" + encodeURIComponent("" + model_jobTitleID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobTitleTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getJobTitleTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL[]>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTitleTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTitleTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobTitleTBLs(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobTitleTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getJobTitleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTitleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTitleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobTitleTBL(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobTitleTBL.fromJS(resultData200, _mappings) : new JobTitleTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putJobTitleTBL(id: number, jobTitleTBL: JobTitleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(jobTitleTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutJobTitleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutJobTitleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutJobTitleTBL(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postJobTitleTBL(jobTitleTBL: JobTitleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(jobTitleTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostJobTitleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostJobTitleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processPostJobTitleTBL(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobTitleTBL.fromJS(resultData200, _mappings) : new JobTitleTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteJobTitleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<JobTitleTBL>> {
        let url_ = this.baseUrl + "/api/JobTitleTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJobTitleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJobTitleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<JobTitleTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<JobTitleTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJobTitleTBL(response: HttpResponseBase): Observable<SwaggerResponse<JobTitleTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobTitleTBL.fromJS(resultData200, _mappings) : new JobTitleTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<JobTitleTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface INationalityTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBLDTO[]>>;
    /**
     * @param model_nationalityID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_nationalityID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBLDTO[]>>;
    /**
     * @param model_nationalityID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_nationalityID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getNationalityTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getNationalityTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putNationalityTBL(id: number, nationalityTBL: NationalityTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postNationalityTBL(nationalityTBL: NationalityTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteNationalityTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class NationalityTBLsClient implements INationalityTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NationalityTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_nationalityID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_nationalityID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_nationalityID !== undefined)
            url_ += "model.nationalityID=" + encodeURIComponent("" + model_nationalityID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NationalityTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_nationalityID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_arName: string, model_enName: string, model_nationalityID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/GetByLike?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_nationalityID !== undefined)
            url_ += "model.nationalityID=" + encodeURIComponent("" + model_nationalityID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NationalityTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getNationalityTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL[]>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNationalityTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNationalityTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetNationalityTBLs(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NationalityTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getNationalityTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNationalityTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNationalityTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetNationalityTBL(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NationalityTBL.fromJS(resultData200, _mappings) : new NationalityTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putNationalityTBL(id: number, nationalityTBL: NationalityTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(nationalityTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutNationalityTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutNationalityTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutNationalityTBL(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postNationalityTBL(nationalityTBL: NationalityTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(nationalityTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostNationalityTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostNationalityTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processPostNationalityTBL(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NationalityTBL.fromJS(resultData200, _mappings) : new NationalityTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteNationalityTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<NationalityTBL>> {
        let url_ = this.baseUrl + "/api/NationalityTBLs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNationalityTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNationalityTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<NationalityTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<NationalityTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNationalityTBL(response: HttpResponseBase): Observable<SwaggerResponse<NationalityTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NationalityTBL.fromJS(resultData200, _mappings) : new NationalityTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<NationalityTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IOegTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllOegType(authorization?: string | null | undefined): Observable<SwaggerResponse<OegTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOegTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<OegType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOegType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OegType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putOegType(id: number, oegType: OegTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postOegType(oegType: OegTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<OegType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteOegType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OegType>>;
}

@Injectable({
    providedIn: 'root'
})
export class OegTypesClient implements IOegTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllOegType(authorization?: string | null | undefined): Observable<SwaggerResponse<OegTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/OegTypes/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOegType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOegType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OegTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OegTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOegType(response: HttpResponseBase): Observable<SwaggerResponse<OegTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OegTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OegTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOegTypes(authorization?: string | null | undefined): Observable<SwaggerResponse<OegType[]>> {
        let url_ = this.baseUrl + "/api/OegTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOegTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOegTypes(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OegType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OegType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetOegTypes(response: HttpResponseBase): Observable<SwaggerResponse<OegType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OegType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OegType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOegType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OegType>> {
        let url_ = this.baseUrl + "/api/OegTypes/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOegType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOegType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OegType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OegType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetOegType(response: HttpResponseBase): Observable<SwaggerResponse<OegType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OegType.fromJS(resultData200, _mappings) : new OegType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OegType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putOegType(id: number, oegType: OegTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/OegTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oegType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutOegType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutOegType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutOegType(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postOegType(oegType: OegTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<OegType>> {
        let url_ = this.baseUrl + "/api/OegTypes/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oegType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostOegType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostOegType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OegType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OegType>>><any>_observableThrow(response_);
        }));
    }

    protected processPostOegType(response: HttpResponseBase): Observable<SwaggerResponse<OegType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OegType.fromJS(resultData200, _mappings) : new OegType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OegType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteOegType(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OegType>> {
        let url_ = this.baseUrl + "/api/OegTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOegType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOegType(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OegType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OegType>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOegType(response: HttpResponseBase): Observable<SwaggerResponse<OegType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OegType.fromJS(resultData200, _mappings) : new OegType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OegType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IOrganizationBasicsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllOrganizationBasics(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasicDTO[]>>;
    /**
     * @param model_orgID (optional) 
     * @param model_landLineNumber (optional) 
     * @param model_pepoleTBLs (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamOrganizationBasic(model_orgArName: string, model_orgEnName: string, model_orgID?: number | null | undefined, model_landLineNumber?: string | null | undefined, model_pepoleTBLs?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasicDTO[]>>;
    /**
     * @param model_orgID (optional) 
     * @param model_landLineNumber (optional) 
     * @param model_pepoleTBLs (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeOrganizationBasic(model_orgArName: string, model_orgEnName: string, model_orgID?: number | null | undefined, model_landLineNumber?: string | null | undefined, model_pepoleTBLs?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasicDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationBasics(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationBasic(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putOrganizationBasic(id: number, organizationBasic: OrganizationBasicDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postOrganizationBasic(organizationBasic: OrganizationBasicDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteOrganizationBasic(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic>>;
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationBasicsClient implements IOrganizationBasicsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllOrganizationBasics(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasicDTO[]>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationBasics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationBasics(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasicDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasicDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganizationBasics(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasicDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationBasicDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasicDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_orgID (optional) 
     * @param model_landLineNumber (optional) 
     * @param model_pepoleTBLs (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamOrganizationBasic(model_orgArName: string, model_orgEnName: string, model_orgID?: number | null | undefined, model_landLineNumber?: string | null | undefined, model_pepoleTBLs?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasicDTO[]>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/GetByParam?";
        if (model_orgArName === undefined || model_orgArName === null)
            throw new Error("The parameter 'model_orgArName' must be defined and cannot be null.");
        else
            url_ += "model.orgArName=" + encodeURIComponent("" + model_orgArName) + "&"; 
        if (model_orgEnName === undefined || model_orgEnName === null)
            throw new Error("The parameter 'model_orgEnName' must be defined and cannot be null.");
        else
            url_ += "model.orgEnName=" + encodeURIComponent("" + model_orgEnName) + "&"; 
        if (model_orgID !== undefined)
            url_ += "model.orgID=" + encodeURIComponent("" + model_orgID) + "&"; 
        if (model_landLineNumber !== undefined)
            url_ += "model.landLineNumber=" + encodeURIComponent("" + model_landLineNumber) + "&"; 
        if (model_pepoleTBLs !== undefined)
            model_pepoleTBLs && model_pepoleTBLs.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.pepoleTBLs[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamOrganizationBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamOrganizationBasic(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasicDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasicDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamOrganizationBasic(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasicDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationBasicDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasicDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_orgID (optional) 
     * @param model_landLineNumber (optional) 
     * @param model_pepoleTBLs (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeOrganizationBasic(model_orgArName: string, model_orgEnName: string, model_orgID?: number | null | undefined, model_landLineNumber?: string | null | undefined, model_pepoleTBLs?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasicDTO[]>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/GetByLike?";
        if (model_orgArName === undefined || model_orgArName === null)
            throw new Error("The parameter 'model_orgArName' must be defined and cannot be null.");
        else
            url_ += "model.orgArName=" + encodeURIComponent("" + model_orgArName) + "&"; 
        if (model_orgEnName === undefined || model_orgEnName === null)
            throw new Error("The parameter 'model_orgEnName' must be defined and cannot be null.");
        else
            url_ += "model.orgEnName=" + encodeURIComponent("" + model_orgEnName) + "&"; 
        if (model_orgID !== undefined)
            url_ += "model.orgID=" + encodeURIComponent("" + model_orgID) + "&"; 
        if (model_landLineNumber !== undefined)
            url_ += "model.landLineNumber=" + encodeURIComponent("" + model_landLineNumber) + "&"; 
        if (model_pepoleTBLs !== undefined)
            model_pepoleTBLs && model_pepoleTBLs.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.pepoleTBLs[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectlikeOrganizationBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectlikeOrganizationBasic(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasicDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasicDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectlikeOrganizationBasic(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasicDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationBasicDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasicDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationBasics(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic[]>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationBasics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationBasics(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasic[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasic[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationBasics(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasic[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationBasic.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasic[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationBasic(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationBasic(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasic>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasic>>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationBasic(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasic>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationBasic.fromJS(resultData200, _mappings) : new OrganizationBasic();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasic>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putOrganizationBasic(id: number, organizationBasic: OrganizationBasicDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(organizationBasic);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutOrganizationBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutOrganizationBasic(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutOrganizationBasic(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postOrganizationBasic(organizationBasic: OrganizationBasicDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(organizationBasic);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostOrganizationBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostOrganizationBasic(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasic>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasic>>><any>_observableThrow(response_);
        }));
    }

    protected processPostOrganizationBasic(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasic>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationBasic.fromJS(resultData200, _mappings) : new OrganizationBasic();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasic>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteOrganizationBasic(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationBasic>> {
        let url_ = this.baseUrl + "/api/OrganizationBasics/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationBasic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationBasic(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationBasic>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationBasic>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationBasic(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationBasic>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationBasic.fromJS(resultData200, _mappings) : new OrganizationBasic();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationBasic>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IOrganizationsProjectsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllOrganizationsProject(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProjectDTO[]>>;
    /**
     * @param model_serNum (optional) 
     * @param model_oegTypeOrgTypeID (optional) 
     * @param model_oegTypeTypeArName (optional) 
     * @param model_oegTypeTypeEnName (optional) 
     * @param model_oegTypeOrganizationsProjects (optional) 
     * @param model_pepoleTBLPeopleID (optional) 
     * @param model_pepoleTBLArName (optional) 
     * @param model_pepoleTBLEnName (optional) 
     * @param model_pepoleTBLMobilePhone (optional) 
     * @param model_pepoleTBLLandLineExt (optional) 
     * @param model_pepoleTBLEmailAdress (optional) 
     * @param model_pepoleTBLOrgID (optional) 
     * @param model_pepoleTBLOrganizationBasicOrgID (optional) 
     * @param model_pepoleTBLOrganizationBasicOrgArName (optional) 
     * @param model_pepoleTBLOrganizationBasicOrgEnName (optional) 
     * @param model_pepoleTBLOrganizationBasicLandLineNumber (optional) 
     * @param model_pepoleTBLOrganizationBasicPepoleTBLs (optional) 
     * @param model_pepoleTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamOrganizationsProject(model_peopleID: number, model_projectID: number, model_orgTypeID: number, model_serNum?: number | null | undefined, model_oegTypeOrgTypeID?: number | null | undefined, model_oegTypeTypeArName?: string | null | undefined, model_oegTypeTypeEnName?: string | null | undefined, model_oegTypeOrganizationsProjects?: any[] | null | undefined, model_pepoleTBLPeopleID?: number | null | undefined, model_pepoleTBLArName?: string | null | undefined, model_pepoleTBLEnName?: string | null | undefined, model_pepoleTBLMobilePhone?: string | null | undefined, model_pepoleTBLLandLineExt?: string | null | undefined, model_pepoleTBLEmailAdress?: string | null | undefined, model_pepoleTBLOrgID?: number | null | undefined, model_pepoleTBLOrganizationBasicOrgID?: number | null | undefined, model_pepoleTBLOrganizationBasicOrgArName?: string | null | undefined, model_pepoleTBLOrganizationBasicOrgEnName?: string | null | undefined, model_pepoleTBLOrganizationBasicLandLineNumber?: string | null | undefined, model_pepoleTBLOrganizationBasicPepoleTBLs?: any[] | null | undefined, model_pepoleTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProjectDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationsProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationsProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putOrganizationsProject(id: number, organizationsProject: OrganizationsProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postOrganizationsProject(organizationsProject: OrganizationsProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteOrganizationsProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject>>;
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationsProjectsClient implements IOrganizationsProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllOrganizationsProject(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationsProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationsProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationsProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationsProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganizationsProject(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationsProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationsProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_serNum (optional) 
     * @param model_oegTypeOrgTypeID (optional) 
     * @param model_oegTypeTypeArName (optional) 
     * @param model_oegTypeTypeEnName (optional) 
     * @param model_oegTypeOrganizationsProjects (optional) 
     * @param model_pepoleTBLPeopleID (optional) 
     * @param model_pepoleTBLArName (optional) 
     * @param model_pepoleTBLEnName (optional) 
     * @param model_pepoleTBLMobilePhone (optional) 
     * @param model_pepoleTBLLandLineExt (optional) 
     * @param model_pepoleTBLEmailAdress (optional) 
     * @param model_pepoleTBLOrgID (optional) 
     * @param model_pepoleTBLOrganizationBasicOrgID (optional) 
     * @param model_pepoleTBLOrganizationBasicOrgArName (optional) 
     * @param model_pepoleTBLOrganizationBasicOrgEnName (optional) 
     * @param model_pepoleTBLOrganizationBasicLandLineNumber (optional) 
     * @param model_pepoleTBLOrganizationBasicPepoleTBLs (optional) 
     * @param model_pepoleTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamOrganizationsProject(model_peopleID: number, model_projectID: number, model_orgTypeID: number, model_serNum?: number | null | undefined, model_oegTypeOrgTypeID?: number | null | undefined, model_oegTypeTypeArName?: string | null | undefined, model_oegTypeTypeEnName?: string | null | undefined, model_oegTypeOrganizationsProjects?: any[] | null | undefined, model_pepoleTBLPeopleID?: number | null | undefined, model_pepoleTBLArName?: string | null | undefined, model_pepoleTBLEnName?: string | null | undefined, model_pepoleTBLMobilePhone?: string | null | undefined, model_pepoleTBLLandLineExt?: string | null | undefined, model_pepoleTBLEmailAdress?: string | null | undefined, model_pepoleTBLOrgID?: number | null | undefined, model_pepoleTBLOrganizationBasicOrgID?: number | null | undefined, model_pepoleTBLOrganizationBasicOrgArName?: string | null | undefined, model_pepoleTBLOrganizationBasicOrgEnName?: string | null | undefined, model_pepoleTBLOrganizationBasicLandLineNumber?: string | null | undefined, model_pepoleTBLOrganizationBasicPepoleTBLs?: any[] | null | undefined, model_pepoleTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/GetByParam?";
        if (model_peopleID === undefined || model_peopleID === null)
            throw new Error("The parameter 'model_peopleID' must be defined and cannot be null.");
        else
            url_ += "model.peopleID=" + encodeURIComponent("" + model_peopleID) + "&"; 
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_orgTypeID === undefined || model_orgTypeID === null)
            throw new Error("The parameter 'model_orgTypeID' must be defined and cannot be null.");
        else
            url_ += "model.orgTypeID=" + encodeURIComponent("" + model_orgTypeID) + "&"; 
        if (model_serNum !== undefined)
            url_ += "model.serNum=" + encodeURIComponent("" + model_serNum) + "&"; 
        if (model_oegTypeOrgTypeID !== undefined)
            url_ += "model.oegTypeOrgTypeID=" + encodeURIComponent("" + model_oegTypeOrgTypeID) + "&"; 
        if (model_oegTypeTypeArName !== undefined)
            url_ += "model.oegTypeTypeArName=" + encodeURIComponent("" + model_oegTypeTypeArName) + "&"; 
        if (model_oegTypeTypeEnName !== undefined)
            url_ += "model.oegTypeTypeEnName=" + encodeURIComponent("" + model_oegTypeTypeEnName) + "&"; 
        if (model_oegTypeOrganizationsProjects !== undefined)
            model_oegTypeOrganizationsProjects && model_oegTypeOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.oegTypeOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_pepoleTBLPeopleID !== undefined)
            url_ += "model.pepoleTBLPeopleID=" + encodeURIComponent("" + model_pepoleTBLPeopleID) + "&"; 
        if (model_pepoleTBLArName !== undefined)
            url_ += "model.pepoleTBLArName=" + encodeURIComponent("" + model_pepoleTBLArName) + "&"; 
        if (model_pepoleTBLEnName !== undefined)
            url_ += "model.pepoleTBLEnName=" + encodeURIComponent("" + model_pepoleTBLEnName) + "&"; 
        if (model_pepoleTBLMobilePhone !== undefined)
            url_ += "model.pepoleTBLMobilePhone=" + encodeURIComponent("" + model_pepoleTBLMobilePhone) + "&"; 
        if (model_pepoleTBLLandLineExt !== undefined)
            url_ += "model.pepoleTBLLandLineExt=" + encodeURIComponent("" + model_pepoleTBLLandLineExt) + "&"; 
        if (model_pepoleTBLEmailAdress !== undefined)
            url_ += "model.pepoleTBLEmailAdress=" + encodeURIComponent("" + model_pepoleTBLEmailAdress) + "&"; 
        if (model_pepoleTBLOrgID !== undefined)
            url_ += "model.pepoleTBLOrgID=" + encodeURIComponent("" + model_pepoleTBLOrgID) + "&"; 
        if (model_pepoleTBLOrganizationBasicOrgID !== undefined)
            url_ += "model.pepoleTBLOrganizationBasicOrgID=" + encodeURIComponent("" + model_pepoleTBLOrganizationBasicOrgID) + "&"; 
        if (model_pepoleTBLOrganizationBasicOrgArName !== undefined)
            url_ += "model.pepoleTBLOrganizationBasicOrgArName=" + encodeURIComponent("" + model_pepoleTBLOrganizationBasicOrgArName) + "&"; 
        if (model_pepoleTBLOrganizationBasicOrgEnName !== undefined)
            url_ += "model.pepoleTBLOrganizationBasicOrgEnName=" + encodeURIComponent("" + model_pepoleTBLOrganizationBasicOrgEnName) + "&"; 
        if (model_pepoleTBLOrganizationBasicLandLineNumber !== undefined)
            url_ += "model.pepoleTBLOrganizationBasicLandLineNumber=" + encodeURIComponent("" + model_pepoleTBLOrganizationBasicLandLineNumber) + "&"; 
        if (model_pepoleTBLOrganizationBasicPepoleTBLs !== undefined)
            model_pepoleTBLOrganizationBasicPepoleTBLs && model_pepoleTBLOrganizationBasicPepoleTBLs.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.pepoleTBLOrganizationBasicPepoleTBLs[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_pepoleTBLOrganizationsProjects !== undefined)
            model_pepoleTBLOrganizationsProjects && model_pepoleTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.pepoleTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamOrganizationsProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamOrganizationsProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationsProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationsProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamOrganizationsProject(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationsProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationsProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationsProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject[]>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationsProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationsProjects(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationsProject[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationsProject[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationsProjects(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationsProject[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationsProject.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationsProject[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getOrganizationsProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationsProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationsProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationsProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationsProject>>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationsProject(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationsProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationsProject.fromJS(resultData200, _mappings) : new OrganizationsProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationsProject>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putOrganizationsProject(id: number, organizationsProject: OrganizationsProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(organizationsProject);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutOrganizationsProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutOrganizationsProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutOrganizationsProject(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postOrganizationsProject(organizationsProject: OrganizationsProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(organizationsProject);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostOrganizationsProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostOrganizationsProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationsProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationsProject>>><any>_observableThrow(response_);
        }));
    }

    protected processPostOrganizationsProject(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationsProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationsProject.fromJS(resultData200, _mappings) : new OrganizationsProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationsProject>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteOrganizationsProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<OrganizationsProject>> {
        let url_ = this.baseUrl + "/api/OrganizationsProjects/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationsProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationsProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<OrganizationsProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<OrganizationsProject>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationsProject(response: HttpResponseBase): Observable<SwaggerResponse<OrganizationsProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationsProject.fromJS(resultData200, _mappings) : new OrganizationsProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<OrganizationsProject>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IPepoleTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllPepole(authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBLDTO[]>>;
    /**
     * @param model_peopleID (optional) 
     * @param model_orgID (optional) 
     * @param model_organizationBasicOrgID (optional) 
     * @param model_organizationBasicOrgArName (optional) 
     * @param model_organizationBasicOrgEnName (optional) 
     * @param model_organizationBasicLandLineNumber (optional) 
     * @param model_organizationBasicPepoleTBLs (optional) 
     * @param model_organizationsProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamContractChange(model_arName: string, model_enName: string, model_mobilePhone: string, model_landLineExt: string, model_emailAdress: string, model_peopleID?: number | null | undefined, model_orgID?: number | null | undefined, model_organizationBasicOrgID?: number | null | undefined, model_organizationBasicOrgArName?: string | null | undefined, model_organizationBasicOrgEnName?: string | null | undefined, model_organizationBasicLandLineNumber?: string | null | undefined, model_organizationBasicPepoleTBLs?: any[] | null | undefined, model_organizationsProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBLDTO[]>>;
    /**
     * @param model_peopleID (optional) 
     * @param model_orgID (optional) 
     * @param model_organizationBasicOrgID (optional) 
     * @param model_organizationBasicOrgArName (optional) 
     * @param model_organizationBasicOrgEnName (optional) 
     * @param model_organizationBasicLandLineNumber (optional) 
     * @param model_organizationBasicPepoleTBLs (optional) 
     * @param model_organizationsProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeContractChange(model_arName: string, model_enName: string, model_mobilePhone: string, model_landLineExt: string, model_emailAdress: string, model_peopleID?: number | null | undefined, model_orgID?: number | null | undefined, model_organizationBasicOrgID?: number | null | undefined, model_organizationBasicOrgArName?: string | null | undefined, model_organizationBasicOrgEnName?: string | null | undefined, model_organizationBasicLandLineNumber?: string | null | undefined, model_organizationBasicPepoleTBLs?: any[] | null | undefined, model_organizationsProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBLDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPepoleTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPepoleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putPepoleTBL(id: number, pepoleTBL: PepoleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postPepoleTBL(pepoleTBL: PepoleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deletePepoleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class PepoleTBLsClient implements IPepoleTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllPepole(authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPepole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPepole(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPepole(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PepoleTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_peopleID (optional) 
     * @param model_orgID (optional) 
     * @param model_organizationBasicOrgID (optional) 
     * @param model_organizationBasicOrgArName (optional) 
     * @param model_organizationBasicOrgEnName (optional) 
     * @param model_organizationBasicLandLineNumber (optional) 
     * @param model_organizationBasicPepoleTBLs (optional) 
     * @param model_organizationsProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamContractChange(model_arName: string, model_enName: string, model_mobilePhone: string, model_landLineExt: string, model_emailAdress: string, model_peopleID?: number | null | undefined, model_orgID?: number | null | undefined, model_organizationBasicOrgID?: number | null | undefined, model_organizationBasicOrgArName?: string | null | undefined, model_organizationBasicOrgEnName?: string | null | undefined, model_organizationBasicLandLineNumber?: string | null | undefined, model_organizationBasicPepoleTBLs?: any[] | null | undefined, model_organizationsProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/GetByParam?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_mobilePhone === undefined || model_mobilePhone === null)
            throw new Error("The parameter 'model_mobilePhone' must be defined and cannot be null.");
        else
            url_ += "model.mobilePhone=" + encodeURIComponent("" + model_mobilePhone) + "&"; 
        if (model_landLineExt === undefined || model_landLineExt === null)
            throw new Error("The parameter 'model_landLineExt' must be defined and cannot be null.");
        else
            url_ += "model.landLineExt=" + encodeURIComponent("" + model_landLineExt) + "&"; 
        if (model_emailAdress === undefined || model_emailAdress === null)
            throw new Error("The parameter 'model_emailAdress' must be defined and cannot be null.");
        else
            url_ += "model.emailAdress=" + encodeURIComponent("" + model_emailAdress) + "&"; 
        if (model_peopleID !== undefined)
            url_ += "model.peopleID=" + encodeURIComponent("" + model_peopleID) + "&"; 
        if (model_orgID !== undefined)
            url_ += "model.orgID=" + encodeURIComponent("" + model_orgID) + "&"; 
        if (model_organizationBasicOrgID !== undefined)
            url_ += "model.organizationBasicOrgID=" + encodeURIComponent("" + model_organizationBasicOrgID) + "&"; 
        if (model_organizationBasicOrgArName !== undefined)
            url_ += "model.organizationBasicOrgArName=" + encodeURIComponent("" + model_organizationBasicOrgArName) + "&"; 
        if (model_organizationBasicOrgEnName !== undefined)
            url_ += "model.organizationBasicOrgEnName=" + encodeURIComponent("" + model_organizationBasicOrgEnName) + "&"; 
        if (model_organizationBasicLandLineNumber !== undefined)
            url_ += "model.organizationBasicLandLineNumber=" + encodeURIComponent("" + model_organizationBasicLandLineNumber) + "&"; 
        if (model_organizationBasicPepoleTBLs !== undefined)
            model_organizationBasicPepoleTBLs && model_organizationBasicPepoleTBLs.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.organizationBasicPepoleTBLs[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_organizationsProjects !== undefined)
            model_organizationsProjects && model_organizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.organizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamContractChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamContractChange(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamContractChange(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PepoleTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_peopleID (optional) 
     * @param model_orgID (optional) 
     * @param model_organizationBasicOrgID (optional) 
     * @param model_organizationBasicOrgArName (optional) 
     * @param model_organizationBasicOrgEnName (optional) 
     * @param model_organizationBasicLandLineNumber (optional) 
     * @param model_organizationBasicPepoleTBLs (optional) 
     * @param model_organizationsProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeContractChange(model_arName: string, model_enName: string, model_mobilePhone: string, model_landLineExt: string, model_emailAdress: string, model_peopleID?: number | null | undefined, model_orgID?: number | null | undefined, model_organizationBasicOrgID?: number | null | undefined, model_organizationBasicOrgArName?: string | null | undefined, model_organizationBasicOrgEnName?: string | null | undefined, model_organizationBasicLandLineNumber?: string | null | undefined, model_organizationBasicPepoleTBLs?: any[] | null | undefined, model_organizationsProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBLDTO[]>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/GetByLike?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_mobilePhone === undefined || model_mobilePhone === null)
            throw new Error("The parameter 'model_mobilePhone' must be defined and cannot be null.");
        else
            url_ += "model.mobilePhone=" + encodeURIComponent("" + model_mobilePhone) + "&"; 
        if (model_landLineExt === undefined || model_landLineExt === null)
            throw new Error("The parameter 'model_landLineExt' must be defined and cannot be null.");
        else
            url_ += "model.landLineExt=" + encodeURIComponent("" + model_landLineExt) + "&"; 
        if (model_emailAdress === undefined || model_emailAdress === null)
            throw new Error("The parameter 'model_emailAdress' must be defined and cannot be null.");
        else
            url_ += "model.emailAdress=" + encodeURIComponent("" + model_emailAdress) + "&"; 
        if (model_peopleID !== undefined)
            url_ += "model.peopleID=" + encodeURIComponent("" + model_peopleID) + "&"; 
        if (model_orgID !== undefined)
            url_ += "model.orgID=" + encodeURIComponent("" + model_orgID) + "&"; 
        if (model_organizationBasicOrgID !== undefined)
            url_ += "model.organizationBasicOrgID=" + encodeURIComponent("" + model_organizationBasicOrgID) + "&"; 
        if (model_organizationBasicOrgArName !== undefined)
            url_ += "model.organizationBasicOrgArName=" + encodeURIComponent("" + model_organizationBasicOrgArName) + "&"; 
        if (model_organizationBasicOrgEnName !== undefined)
            url_ += "model.organizationBasicOrgEnName=" + encodeURIComponent("" + model_organizationBasicOrgEnName) + "&"; 
        if (model_organizationBasicLandLineNumber !== undefined)
            url_ += "model.organizationBasicLandLineNumber=" + encodeURIComponent("" + model_organizationBasicLandLineNumber) + "&"; 
        if (model_organizationBasicPepoleTBLs !== undefined)
            model_organizationBasicPepoleTBLs && model_organizationBasicPepoleTBLs.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.organizationBasicPepoleTBLs[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_organizationsProjects !== undefined)
            model_organizationsProjects && model_organizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.organizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectlikeContractChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectlikeContractChange(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBLDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBLDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectlikeContractChange(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBLDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PepoleTBLDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBLDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPepoleTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL[]>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPepoleTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPepoleTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetPepoleTBLs(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PepoleTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPepoleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPepoleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPepoleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetPepoleTBL(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PepoleTBL.fromJS(resultData200, _mappings) : new PepoleTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putPepoleTBL(id: number, pepoleTBL: PepoleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pepoleTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutPepoleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutPepoleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutPepoleTBL(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postPepoleTBL(pepoleTBL: PepoleTBLDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pepoleTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPepoleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPepoleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processPostPepoleTBL(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PepoleTBL.fromJS(resultData200, _mappings) : new PepoleTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deletePepoleTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PepoleTBL>> {
        let url_ = this.baseUrl + "/api/PepoleTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePepoleTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePepoleTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PepoleTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PepoleTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePepoleTBL(response: HttpResponseBase): Observable<SwaggerResponse<PepoleTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PepoleTBL.fromJS(resultData200, _mappings) : new PepoleTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PepoleTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IPositionInProjectsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllPositionInProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProjectDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_projectEmployees (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamContractChange(model_arName: string, model_enName: string, model_iD?: number | null | undefined, model_projectEmployees?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProjectDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPositionInProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPositionInProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putPositionInProject(id: number, positionInProject: PositionInProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postPositionInProject(positionInProject: PositionInProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deletePositionInProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject>>;
}

@Injectable({
    providedIn: 'root'
})
export class PositionInProjectsClient implements IPositionInProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllPositionInProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPositionInProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPositionInProjects(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PositionInProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PositionInProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPositionInProjects(response: HttpResponseBase): Observable<SwaggerResponse<PositionInProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionInProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PositionInProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_projectEmployees (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamContractChange(model_arName: string, model_enName: string, model_iD?: number | null | undefined, model_projectEmployees?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/GetByParam?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_projectEmployees !== undefined)
            model_projectEmployees && model_projectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamContractChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamContractChange(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PositionInProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PositionInProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamContractChange(response: HttpResponseBase): Observable<SwaggerResponse<PositionInProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionInProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PositionInProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPositionInProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject[]>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositionInProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositionInProjects(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PositionInProject[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PositionInProject[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetPositionInProjects(response: HttpResponseBase): Observable<SwaggerResponse<PositionInProject[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionInProject.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PositionInProject[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getPositionInProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositionInProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositionInProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PositionInProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PositionInProject>>><any>_observableThrow(response_);
        }));
    }

    protected processGetPositionInProject(response: HttpResponseBase): Observable<SwaggerResponse<PositionInProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionInProject.fromJS(resultData200, _mappings) : new PositionInProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PositionInProject>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putPositionInProject(id: number, positionInProject: PositionInProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(positionInProject);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutPositionInProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutPositionInProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutPositionInProject(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postPositionInProject(positionInProject: PositionInProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(positionInProject);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPositionInProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPositionInProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PositionInProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PositionInProject>>><any>_observableThrow(response_);
        }));
    }

    protected processPostPositionInProject(response: HttpResponseBase): Observable<SwaggerResponse<PositionInProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionInProject.fromJS(resultData200, _mappings) : new PositionInProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PositionInProject>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deletePositionInProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<PositionInProject>> {
        let url_ = this.baseUrl + "/api/PositionInProjects/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePositionInProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePositionInProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<PositionInProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<PositionInProject>>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePositionInProject(response: HttpResponseBase): Observable<SwaggerResponse<PositionInProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionInProject.fromJS(resultData200, _mappings) : new PositionInProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PositionInProject>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IProiertyTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyTypeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, proiertyType: ProiertyTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(proiertyType: ProiertyTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType>>;
}

@Injectable({
    providedIn: 'root'
})
export class ProiertyTypesClient implements IProiertyTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/ProiertyTypes/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProiertyTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProiertyTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<ProiertyTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProiertyTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProiertyTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/ProiertyTypes/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProiertyTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProiertyTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<ProiertyTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProiertyTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProiertyTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType[]>> {
        let url_ = this.baseUrl + "/api/ProiertyTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProiertyType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProiertyType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<ProiertyType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProiertyType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProiertyType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType>> {
        let url_ = this.baseUrl + "/api/DivisionTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProiertyType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProiertyType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<ProiertyType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProiertyType.fromJS(resultData200, _mappings) : new ProiertyType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProiertyType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, proiertyType: ProiertyTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ProiertyTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(proiertyType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType>> {
        let url_ = this.baseUrl + "/api/ProiertyTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProiertyType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProiertyType>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<ProiertyType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProiertyType.fromJS(resultData200, _mappings) : new ProiertyType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProiertyType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(proiertyType: ProiertyTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ProiertyType>> {
        let url_ = this.baseUrl + "/api/ProiertyTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(proiertyType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProiertyType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProiertyType>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<ProiertyType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProiertyType.fromJS(resultData200, _mappings) : new ProiertyType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProiertyType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IProjectEmployeesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllProjectEmployees(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployeeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_positionInProject1ID (optional) 
     * @param model_positionInProject1ArName (optional) 
     * @param model_positionInProject1EnName (optional) 
     * @param model_positionInProject1ProjectEmployees (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamProjectEmployees(model_projectID: number, model_empID: number, model_startFrom: Date, model_endTo: Date, model_positionInProject: number, model_iD?: number | null | undefined, model_positionInProject1ID?: number | null | undefined, model_positionInProject1ArName?: string | null | undefined, model_positionInProject1EnName?: string | null | undefined, model_positionInProject1ProjectEmployees?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployeeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param model_positionInProject1ID (optional) 
     * @param model_positionInProject1ArName (optional) 
     * @param model_positionInProject1EnName (optional) 
     * @param model_positionInProject1ProjectEmployees (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeProjectEmployees(model_projectID: number, model_empID: number, model_startFrom: Date, model_endTo: Date, model_positionInProject: number, model_iD?: number | null | undefined, model_positionInProject1ID?: number | null | undefined, model_positionInProject1ArName?: string | null | undefined, model_positionInProject1EnName?: string | null | undefined, model_positionInProject1ProjectEmployees?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployeeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectEmployees(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectEmployee(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putProjectEmployee(id: number, projectEmployee: ProjectEmployeeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postProjectEmployee(projectEmployee: ProjectEmployeeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteProjectEmployee(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee>>;
}

@Injectable({
    providedIn: 'root'
})
export class ProjectEmployeesClient implements IProjectEmployeesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllProjectEmployees(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployeeDTO[]>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectEmployees(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployeeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployeeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectEmployees(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployeeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployeeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_positionInProject1ID (optional) 
     * @param model_positionInProject1ArName (optional) 
     * @param model_positionInProject1EnName (optional) 
     * @param model_positionInProject1ProjectEmployees (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamProjectEmployees(model_projectID: number, model_empID: number, model_startFrom: Date, model_endTo: Date, model_positionInProject: number, model_iD?: number | null | undefined, model_positionInProject1ID?: number | null | undefined, model_positionInProject1ArName?: string | null | undefined, model_positionInProject1EnName?: string | null | undefined, model_positionInProject1ProjectEmployees?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployeeDTO[]>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/GetByParam?";
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_empID === undefined || model_empID === null)
            throw new Error("The parameter 'model_empID' must be defined and cannot be null.");
        else
            url_ += "model.empID=" + encodeURIComponent("" + model_empID) + "&"; 
        if (model_startFrom === undefined || model_startFrom === null)
            throw new Error("The parameter 'model_startFrom' must be defined and cannot be null.");
        else
            url_ += "model.startFrom=" + encodeURIComponent(model_startFrom ? "" + model_startFrom.toJSON() : "") + "&"; 
        if (model_endTo === undefined || model_endTo === null)
            throw new Error("The parameter 'model_endTo' must be defined and cannot be null.");
        else
            url_ += "model.endTo=" + encodeURIComponent(model_endTo ? "" + model_endTo.toJSON() : "") + "&"; 
        if (model_positionInProject === undefined || model_positionInProject === null)
            throw new Error("The parameter 'model_positionInProject' must be defined and cannot be null.");
        else
            url_ += "model.positionInProject=" + encodeURIComponent("" + model_positionInProject) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_positionInProject1ID !== undefined)
            url_ += "model.positionInProject1ID=" + encodeURIComponent("" + model_positionInProject1ID) + "&"; 
        if (model_positionInProject1ArName !== undefined)
            url_ += "model.positionInProject1ArName=" + encodeURIComponent("" + model_positionInProject1ArName) + "&"; 
        if (model_positionInProject1EnName !== undefined)
            url_ += "model.positionInProject1EnName=" + encodeURIComponent("" + model_positionInProject1EnName) + "&"; 
        if (model_positionInProject1ProjectEmployees !== undefined)
            model_positionInProject1ProjectEmployees && model_positionInProject1ProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.positionInProject1ProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamProjectEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamProjectEmployees(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployeeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployeeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamProjectEmployees(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployeeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployeeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param model_positionInProject1ID (optional) 
     * @param model_positionInProject1ArName (optional) 
     * @param model_positionInProject1EnName (optional) 
     * @param model_positionInProject1ProjectEmployees (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeProjectEmployees(model_projectID: number, model_empID: number, model_startFrom: Date, model_endTo: Date, model_positionInProject: number, model_iD?: number | null | undefined, model_positionInProject1ID?: number | null | undefined, model_positionInProject1ArName?: string | null | undefined, model_positionInProject1EnName?: string | null | undefined, model_positionInProject1ProjectEmployees?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployeeDTO[]>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/GetByLike?";
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_empID === undefined || model_empID === null)
            throw new Error("The parameter 'model_empID' must be defined and cannot be null.");
        else
            url_ += "model.empID=" + encodeURIComponent("" + model_empID) + "&"; 
        if (model_startFrom === undefined || model_startFrom === null)
            throw new Error("The parameter 'model_startFrom' must be defined and cannot be null.");
        else
            url_ += "model.startFrom=" + encodeURIComponent(model_startFrom ? "" + model_startFrom.toJSON() : "") + "&"; 
        if (model_endTo === undefined || model_endTo === null)
            throw new Error("The parameter 'model_endTo' must be defined and cannot be null.");
        else
            url_ += "model.endTo=" + encodeURIComponent(model_endTo ? "" + model_endTo.toJSON() : "") + "&"; 
        if (model_positionInProject === undefined || model_positionInProject === null)
            throw new Error("The parameter 'model_positionInProject' must be defined and cannot be null.");
        else
            url_ += "model.positionInProject=" + encodeURIComponent("" + model_positionInProject) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        if (model_positionInProject1ID !== undefined)
            url_ += "model.positionInProject1ID=" + encodeURIComponent("" + model_positionInProject1ID) + "&"; 
        if (model_positionInProject1ArName !== undefined)
            url_ += "model.positionInProject1ArName=" + encodeURIComponent("" + model_positionInProject1ArName) + "&"; 
        if (model_positionInProject1EnName !== undefined)
            url_ += "model.positionInProject1EnName=" + encodeURIComponent("" + model_positionInProject1EnName) + "&"; 
        if (model_positionInProject1ProjectEmployees !== undefined)
            model_positionInProject1ProjectEmployees && model_positionInProject1ProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.positionInProject1ProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectlikeProjectEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectlikeProjectEmployees(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployeeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployeeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectlikeProjectEmployees(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployeeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployeeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectEmployees(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee[]>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectEmployees(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployee[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployee[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectEmployees(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployee[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectEmployee.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployee[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectEmployee(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectEmployee(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployee>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployee>>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectEmployee(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployee>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectEmployee.fromJS(resultData200, _mappings) : new ProjectEmployee();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployee>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putProjectEmployee(id: number, projectEmployee: ProjectEmployeeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectEmployee);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutProjectEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutProjectEmployee(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutProjectEmployee(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postProjectEmployee(projectEmployee: ProjectEmployeeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectEmployee);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostProjectEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostProjectEmployee(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployee>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployee>>><any>_observableThrow(response_);
        }));
    }

    protected processPostProjectEmployee(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployee>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectEmployee.fromJS(resultData200, _mappings) : new ProjectEmployee();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployee>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteProjectEmployee(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectEmployee>> {
        let url_ = this.baseUrl + "/api/ProjectEmployees/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProjectEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProjectEmployee(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectEmployee>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectEmployee>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProjectEmployee(response: HttpResponseBase): Observable<SwaggerResponse<ProjectEmployee>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectEmployee.fromJS(resultData200, _mappings) : new ProjectEmployee();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectEmployee>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IProjectTBLsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllProjectTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO[]>>;
    /**
     * @param model_projectID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamProjectTBL(model_projectNumber: string, model_arName: string, model_enName: string, model_startDate: Date, model_mainContractAmount: number, model_endDate: Date, model_isActiveProject: boolean, model_projectID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO[]>>;
    /**
     * @param model_projectID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeContractChange(model_projectNumber: string, model_arName: string, model_enName: string, model_startDate: Date, model_mainContractAmount: number, model_endDate: Date, model_isActiveProject: boolean, model_projectID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectTBL[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectsByEmpID(empID: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectTBL>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putProjectTBL(id: number, projectTBL: ProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postProjectTBL(projectTBL: ProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteProjectTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectTBL>>;
}

@Injectable({
    providedIn: 'root'
})
export class ProjectTBLsClient implements IProjectTBLsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllProjectTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectTBLs(response: HttpResponseBase): Observable<SwaggerResponse<ProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_projectID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamProjectTBL(model_projectNumber: string, model_arName: string, model_enName: string, model_startDate: Date, model_mainContractAmount: number, model_endDate: Date, model_isActiveProject: boolean, model_projectID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/GetByParam?";
        if (model_projectNumber === undefined || model_projectNumber === null)
            throw new Error("The parameter 'model_projectNumber' must be defined and cannot be null.");
        else
            url_ += "model.projectNumber=" + encodeURIComponent("" + model_projectNumber) + "&"; 
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_mainContractAmount === undefined || model_mainContractAmount === null)
            throw new Error("The parameter 'model_mainContractAmount' must be defined and cannot be null.");
        else
            url_ += "model.mainContractAmount=" + encodeURIComponent("" + model_mainContractAmount) + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_isActiveProject === undefined || model_isActiveProject === null)
            throw new Error("The parameter 'model_isActiveProject' must be defined and cannot be null.");
        else
            url_ += "model.isActiveProject=" + encodeURIComponent("" + model_isActiveProject) + "&"; 
        if (model_projectID !== undefined)
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamProjectTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamProjectTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamProjectTBL(response: HttpResponseBase): Observable<SwaggerResponse<ProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_projectID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeContractChange(model_projectNumber: string, model_arName: string, model_enName: string, model_startDate: Date, model_mainContractAmount: number, model_endDate: Date, model_isActiveProject: boolean, model_projectID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/GetByLike?";
        if (model_projectNumber === undefined || model_projectNumber === null)
            throw new Error("The parameter 'model_projectNumber' must be defined and cannot be null.");
        else
            url_ += "model.projectNumber=" + encodeURIComponent("" + model_projectNumber) + "&"; 
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_mainContractAmount === undefined || model_mainContractAmount === null)
            throw new Error("The parameter 'model_mainContractAmount' must be defined and cannot be null.");
        else
            url_ += "model.mainContractAmount=" + encodeURIComponent("" + model_mainContractAmount) + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_isActiveProject === undefined || model_isActiveProject === null)
            throw new Error("The parameter 'model_isActiveProject' must be defined and cannot be null.");
        else
            url_ += "model.isActiveProject=" + encodeURIComponent("" + model_isActiveProject) + "&"; 
        if (model_projectID !== undefined)
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectlikeContractChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectlikeContractChange(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectlikeContractChange(response: HttpResponseBase): Observable<SwaggerResponse<ProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectTBLs(authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectTBL[]>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectTBLs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectTBLs(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectTBL[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectTBL[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectTBLs(response: HttpResponseBase): Observable<SwaggerResponse<ProjectTBL[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTBL.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectTBL[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectsByEmpID(empID: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/GetProjectsByEmpID/{EmpID}";
        if (empID === undefined || empID === null)
            throw new Error("The parameter 'empID' must be defined.");
        url_ = url_.replace("{EmpID}", encodeURIComponent("" + empID)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectsByEmpID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectsByEmpID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectDTO>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectDTO>>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectsByEmpID(response: HttpResponseBase): Observable<SwaggerResponse<ProjectDTO>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectDTO.fromJS(resultData200, _mappings) : new ProjectDTO();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectDTO>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getProjectTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectTBL>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectTBL(response: HttpResponseBase): Observable<SwaggerResponse<ProjectTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectTBL.fromJS(resultData200, _mappings) : new ProjectTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putProjectTBL(id: number, projectTBL: ProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutProjectTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutProjectTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutProjectTBL(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postProjectTBL(projectTBL: ProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectDTO>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectTBL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostProjectTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostProjectTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectDTO>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectDTO>>><any>_observableThrow(response_);
        }));
    }

    protected processPostProjectTBL(response: HttpResponseBase): Observable<SwaggerResponse<ProjectDTO>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectDTO.fromJS(resultData200, _mappings) : new ProjectDTO();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectDTO>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteProjectTBL(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<ProjectTBL>> {
        let url_ = this.baseUrl + "/api/ProjectTBLs/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProjectTBL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProjectTBL(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<ProjectTBL>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<ProjectTBL>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProjectTBL(response: HttpResponseBase): Observable<SwaggerResponse<ProjectTBL>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectTBL.fromJS(resultData200, _mappings) : new ProjectTBL();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ProjectTBL>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IRoleInTasksClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTaskDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTaskDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, roleInTask: RoleInTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(roleInTask: RoleInTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask>>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleInTasksClient implements IRoleInTasksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTaskDTO[]>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<RoleInTaskDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<RoleInTaskDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<RoleInTaskDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleInTaskDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RoleInTaskDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTaskDTO[]>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<RoleInTaskDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<RoleInTaskDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<RoleInTaskDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleInTaskDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RoleInTaskDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask[]>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<RoleInTask[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<RoleInTask[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<RoleInTask[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleInTask.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RoleInTask[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<RoleInTask>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<RoleInTask>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<RoleInTask>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleInTask.fromJS(resultData200, _mappings) : new RoleInTask();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RoleInTask>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, roleInTask: RoleInTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleInTask);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(roleInTask: RoleInTaskDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleInTask);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<RoleInTask>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<RoleInTask>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<RoleInTask>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleInTask.fromJS(resultData200, _mappings) : new RoleInTask();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RoleInTask>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<RoleInTask>> {
        let url_ = this.baseUrl + "/api/RoleInTasks/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<RoleInTask>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<RoleInTask>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<RoleInTask>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleInTask.fromJS(resultData200, _mappings) : new RoleInTask();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<RoleInTask>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface IStageProjectsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllStageProject(authorization?: string | null | undefined): Observable<SwaggerResponse<StageProjectDTO[]>>;
    /**
     * @param model_stageID (optional) 
     * @param model_deliverableStages (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamStageProjects(model_projectID: number, model_stageArName: string, model_stageEnName: string, model_startDate: Date, model_endDate: Date, model_stageBudget: number, model_stageID?: number | null | undefined, model_deliverableStages?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProjectDTO[]>>;
    /**
     * @param model_stageID (optional) 
     * @param model_deliverableStages (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeStageProjects(model_projectID: number, model_stageArName: string, model_stageEnName: string, model_startDate: Date, model_endDate: Date, model_stageBudget: number, model_stageID?: number | null | undefined, model_deliverableStages?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProjectDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getStageProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getStageProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putStageProject(id: number, stageProject: StageProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postStageProject(stageProject: StageProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteStageProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject>>;
}

@Injectable({
    providedIn: 'root'
})
export class StageProjectsClient implements IStageProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllStageProject(authorization?: string | null | undefined): Observable<SwaggerResponse<StageProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/StageProjects/GetAllS";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStageProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStageProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStageProject(response: HttpResponseBase): Observable<SwaggerResponse<StageProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_stageID (optional) 
     * @param model_deliverableStages (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectParamStageProjects(model_projectID: number, model_stageArName: string, model_stageEnName: string, model_startDate: Date, model_endDate: Date, model_stageBudget: number, model_stageID?: number | null | undefined, model_deliverableStages?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/StageProjects/GetByParam?";
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_stageArName === undefined || model_stageArName === null)
            throw new Error("The parameter 'model_stageArName' must be defined and cannot be null.");
        else
            url_ += "model.stageArName=" + encodeURIComponent("" + model_stageArName) + "&"; 
        if (model_stageEnName === undefined || model_stageEnName === null)
            throw new Error("The parameter 'model_stageEnName' must be defined and cannot be null.");
        else
            url_ += "model.stageEnName=" + encodeURIComponent("" + model_stageEnName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_stageBudget === undefined || model_stageBudget === null)
            throw new Error("The parameter 'model_stageBudget' must be defined and cannot be null.");
        else
            url_ += "model.stageBudget=" + encodeURIComponent("" + model_stageBudget) + "&"; 
        if (model_stageID !== undefined)
            url_ += "model.stageID=" + encodeURIComponent("" + model_stageID) + "&"; 
        if (model_deliverableStages !== undefined)
            model_deliverableStages && model_deliverableStages.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.deliverableStages[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectParamStageProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectParamStageProjects(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectParamStageProjects(response: HttpResponseBase): Observable<SwaggerResponse<StageProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_stageID (optional) 
     * @param model_deliverableStages (optional) 
     * @param model_projectTBLProjectID (optional) 
     * @param model_projectTBLProjectNumber (optional) 
     * @param model_projectTBLArName (optional) 
     * @param model_projectTBLEnName (optional) 
     * @param model_projectTBLStartDate (optional) 
     * @param model_projectTBLMainContractAmount (optional) 
     * @param model_projectTBLEndDate (optional) 
     * @param model_projectTBLIsActiveProject (optional) 
     * @param model_projectTBLContractsChanges (optional) 
     * @param model_projectTBLOrganizationsProjects (optional) 
     * @param model_projectTBLProjectEmployees (optional) 
     * @param model_projectTBLStageProjects (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    selectlikeStageProjects(model_projectID: number, model_stageArName: string, model_stageEnName: string, model_startDate: Date, model_endDate: Date, model_stageBudget: number, model_stageID?: number | null | undefined, model_deliverableStages?: any[] | null | undefined, model_projectTBLProjectID?: number | null | undefined, model_projectTBLProjectNumber?: string | null | undefined, model_projectTBLArName?: string | null | undefined, model_projectTBLEnName?: string | null | undefined, model_projectTBLStartDate?: Date | null | undefined, model_projectTBLMainContractAmount?: number | null | undefined, model_projectTBLEndDate?: Date | null | undefined, model_projectTBLIsActiveProject?: boolean | null | undefined, model_projectTBLContractsChanges?: any[] | null | undefined, model_projectTBLOrganizationsProjects?: any[] | null | undefined, model_projectTBLProjectEmployees?: any[] | null | undefined, model_projectTBLStageProjects?: any[] | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProjectDTO[]>> {
        let url_ = this.baseUrl + "/api/StageProjects/GetByLike?";
        if (model_projectID === undefined || model_projectID === null)
            throw new Error("The parameter 'model_projectID' must be defined and cannot be null.");
        else
            url_ += "model.projectID=" + encodeURIComponent("" + model_projectID) + "&"; 
        if (model_stageArName === undefined || model_stageArName === null)
            throw new Error("The parameter 'model_stageArName' must be defined and cannot be null.");
        else
            url_ += "model.stageArName=" + encodeURIComponent("" + model_stageArName) + "&"; 
        if (model_stageEnName === undefined || model_stageEnName === null)
            throw new Error("The parameter 'model_stageEnName' must be defined and cannot be null.");
        else
            url_ += "model.stageEnName=" + encodeURIComponent("" + model_stageEnName) + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_stageBudget === undefined || model_stageBudget === null)
            throw new Error("The parameter 'model_stageBudget' must be defined and cannot be null.");
        else
            url_ += "model.stageBudget=" + encodeURIComponent("" + model_stageBudget) + "&"; 
        if (model_stageID !== undefined)
            url_ += "model.stageID=" + encodeURIComponent("" + model_stageID) + "&"; 
        if (model_deliverableStages !== undefined)
            model_deliverableStages && model_deliverableStages.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.deliverableStages[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectID !== undefined)
            url_ += "model.projectTBLProjectID=" + encodeURIComponent("" + model_projectTBLProjectID) + "&"; 
        if (model_projectTBLProjectNumber !== undefined)
            url_ += "model.projectTBLProjectNumber=" + encodeURIComponent("" + model_projectTBLProjectNumber) + "&"; 
        if (model_projectTBLArName !== undefined)
            url_ += "model.projectTBLArName=" + encodeURIComponent("" + model_projectTBLArName) + "&"; 
        if (model_projectTBLEnName !== undefined)
            url_ += "model.projectTBLEnName=" + encodeURIComponent("" + model_projectTBLEnName) + "&"; 
        if (model_projectTBLStartDate !== undefined)
            url_ += "model.projectTBLStartDate=" + encodeURIComponent(model_projectTBLStartDate ? "" + model_projectTBLStartDate.toJSON() : "") + "&"; 
        if (model_projectTBLMainContractAmount !== undefined)
            url_ += "model.projectTBLMainContractAmount=" + encodeURIComponent("" + model_projectTBLMainContractAmount) + "&"; 
        if (model_projectTBLEndDate !== undefined)
            url_ += "model.projectTBLEndDate=" + encodeURIComponent(model_projectTBLEndDate ? "" + model_projectTBLEndDate.toJSON() : "") + "&"; 
        if (model_projectTBLIsActiveProject !== undefined)
            url_ += "model.projectTBLIsActiveProject=" + encodeURIComponent("" + model_projectTBLIsActiveProject) + "&"; 
        if (model_projectTBLContractsChanges !== undefined)
            model_projectTBLContractsChanges && model_projectTBLContractsChanges.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLContractsChanges[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLOrganizationsProjects !== undefined)
            model_projectTBLOrganizationsProjects && model_projectTBLOrganizationsProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLOrganizationsProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLProjectEmployees !== undefined)
            model_projectTBLProjectEmployees && model_projectTBLProjectEmployees.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLProjectEmployees[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (model_projectTBLStageProjects !== undefined)
            model_projectTBLStageProjects && model_projectTBLStageProjects.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "model.projectTBLStageProjects[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectlikeStageProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectlikeStageProjects(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProjectDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProjectDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processSelectlikeStageProjects(response: HttpResponseBase): Observable<SwaggerResponse<StageProjectDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageProjectDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProjectDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getStageProjects(authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject[]>> {
        let url_ = this.baseUrl + "/api/StageProjects/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageProjects(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProject[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProject[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetStageProjects(response: HttpResponseBase): Observable<SwaggerResponse<StageProject[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StageProject.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProject[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getStageProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject>> {
        let url_ = this.baseUrl + "/api/StageProjects/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProject>>><any>_observableThrow(response_);
        }));
    }

    protected processGetStageProject(response: HttpResponseBase): Observable<SwaggerResponse<StageProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StageProject.fromJS(resultData200, _mappings) : new StageProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProject>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    putStageProject(id: number, stageProject: StageProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/StageProjects/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stageProject);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutStageProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutStageProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processPutStageProject(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    postStageProject(stageProject: StageProjectDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject>> {
        let url_ = this.baseUrl + "/api/StageProjects/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stageProject);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostStageProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostStageProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProject>>><any>_observableThrow(response_);
        }));
    }

    protected processPostStageProject(response: HttpResponseBase): Observable<SwaggerResponse<StageProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StageProject.fromJS(resultData200, _mappings) : new StageProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProject>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    deleteStageProject(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<StageProject>> {
        let url_ = this.baseUrl + "/api/StageProjects/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStageProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStageProject(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<StageProject>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<StageProject>>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStageProject(response: HttpResponseBase): Observable<SwaggerResponse<StageProject>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StageProject.fromJS(resultData200, _mappings) : new StageProject();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<StageProject>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface ITaskOperationsClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperationDTO[]>>;
    /**
     * @param model_taskID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_taskName: string, model_creatorEmp: number, model_creationDate: Date, model_startDate: Date, model_endDate: Date, model_parentID: number, model_deliverableID: number, model_taskStatus: boolean, model_taskType: number, model_taskProierty: number, model_attachments: string, model_taskID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperationDTO[]>>;
    /**
     * @param model_taskID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_taskName: string, model_creatorEmp: number, model_creationDate: Date, model_startDate: Date, model_endDate: Date, model_parentID: number, model_deliverableID: number, model_taskStatus: boolean, model_taskType: number, model_taskProierty: number, model_attachments: string, model_taskID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperationDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, taskOperation: TaskOperationDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(taskOperation: TaskOperationDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation>>;
}

@Injectable({
    providedIn: 'root'
})
export class TaskOperationsClient implements ITaskOperationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperationDTO[]>> {
        let url_ = this.baseUrl + "/api/TaskOperations/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperationDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperationDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperationDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskOperationDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperationDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_taskID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_taskName: string, model_creatorEmp: number, model_creationDate: Date, model_startDate: Date, model_endDate: Date, model_parentID: number, model_deliverableID: number, model_taskStatus: boolean, model_taskType: number, model_taskProierty: number, model_attachments: string, model_taskID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperationDTO[]>> {
        let url_ = this.baseUrl + "/api/TaskOperations/GetByParams?";
        if (model_taskName === undefined || model_taskName === null)
            throw new Error("The parameter 'model_taskName' must be defined and cannot be null.");
        else
            url_ += "model.taskName=" + encodeURIComponent("" + model_taskName) + "&"; 
        if (model_creatorEmp === undefined || model_creatorEmp === null)
            throw new Error("The parameter 'model_creatorEmp' must be defined and cannot be null.");
        else
            url_ += "model.creatorEmp=" + encodeURIComponent("" + model_creatorEmp) + "&"; 
        if (model_creationDate === undefined || model_creationDate === null)
            throw new Error("The parameter 'model_creationDate' must be defined and cannot be null.");
        else
            url_ += "model.creationDate=" + encodeURIComponent(model_creationDate ? "" + model_creationDate.toJSON() : "") + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_parentID === undefined || model_parentID === null)
            throw new Error("The parameter 'model_parentID' must be defined and cannot be null.");
        else
            url_ += "model.parentID=" + encodeURIComponent("" + model_parentID) + "&"; 
        if (model_deliverableID === undefined || model_deliverableID === null)
            throw new Error("The parameter 'model_deliverableID' must be defined and cannot be null.");
        else
            url_ += "model.deliverableID=" + encodeURIComponent("" + model_deliverableID) + "&"; 
        if (model_taskStatus === undefined || model_taskStatus === null)
            throw new Error("The parameter 'model_taskStatus' must be defined and cannot be null.");
        else
            url_ += "model.taskStatus=" + encodeURIComponent("" + model_taskStatus) + "&"; 
        if (model_taskType === undefined || model_taskType === null)
            throw new Error("The parameter 'model_taskType' must be defined and cannot be null.");
        else
            url_ += "model.taskType=" + encodeURIComponent("" + model_taskType) + "&"; 
        if (model_taskProierty === undefined || model_taskProierty === null)
            throw new Error("The parameter 'model_taskProierty' must be defined and cannot be null.");
        else
            url_ += "model.taskProierty=" + encodeURIComponent("" + model_taskProierty) + "&"; 
        if (model_attachments === undefined || model_attachments === null)
            throw new Error("The parameter 'model_attachments' must be defined and cannot be null.");
        else
            url_ += "model.attachments=" + encodeURIComponent("" + model_attachments) + "&"; 
        if (model_taskID !== undefined)
            url_ += "model.taskID=" + encodeURIComponent("" + model_taskID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperationDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperationDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperationDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskOperationDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperationDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_taskID (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByLike(model_taskName: string, model_creatorEmp: number, model_creationDate: Date, model_startDate: Date, model_endDate: Date, model_parentID: number, model_deliverableID: number, model_taskStatus: boolean, model_taskType: number, model_taskProierty: number, model_attachments: string, model_taskID?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperationDTO[]>> {
        let url_ = this.baseUrl + "/api/TaskOperations/GetByLike?";
        if (model_taskName === undefined || model_taskName === null)
            throw new Error("The parameter 'model_taskName' must be defined and cannot be null.");
        else
            url_ += "model.taskName=" + encodeURIComponent("" + model_taskName) + "&"; 
        if (model_creatorEmp === undefined || model_creatorEmp === null)
            throw new Error("The parameter 'model_creatorEmp' must be defined and cannot be null.");
        else
            url_ += "model.creatorEmp=" + encodeURIComponent("" + model_creatorEmp) + "&"; 
        if (model_creationDate === undefined || model_creationDate === null)
            throw new Error("The parameter 'model_creationDate' must be defined and cannot be null.");
        else
            url_ += "model.creationDate=" + encodeURIComponent(model_creationDate ? "" + model_creationDate.toJSON() : "") + "&"; 
        if (model_startDate === undefined || model_startDate === null)
            throw new Error("The parameter 'model_startDate' must be defined and cannot be null.");
        else
            url_ += "model.startDate=" + encodeURIComponent(model_startDate ? "" + model_startDate.toJSON() : "") + "&"; 
        if (model_endDate === undefined || model_endDate === null)
            throw new Error("The parameter 'model_endDate' must be defined and cannot be null.");
        else
            url_ += "model.endDate=" + encodeURIComponent(model_endDate ? "" + model_endDate.toJSON() : "") + "&"; 
        if (model_parentID === undefined || model_parentID === null)
            throw new Error("The parameter 'model_parentID' must be defined and cannot be null.");
        else
            url_ += "model.parentID=" + encodeURIComponent("" + model_parentID) + "&"; 
        if (model_deliverableID === undefined || model_deliverableID === null)
            throw new Error("The parameter 'model_deliverableID' must be defined and cannot be null.");
        else
            url_ += "model.deliverableID=" + encodeURIComponent("" + model_deliverableID) + "&"; 
        if (model_taskStatus === undefined || model_taskStatus === null)
            throw new Error("The parameter 'model_taskStatus' must be defined and cannot be null.");
        else
            url_ += "model.taskStatus=" + encodeURIComponent("" + model_taskStatus) + "&"; 
        if (model_taskType === undefined || model_taskType === null)
            throw new Error("The parameter 'model_taskType' must be defined and cannot be null.");
        else
            url_ += "model.taskType=" + encodeURIComponent("" + model_taskType) + "&"; 
        if (model_taskProierty === undefined || model_taskProierty === null)
            throw new Error("The parameter 'model_taskProierty' must be defined and cannot be null.");
        else
            url_ += "model.taskProierty=" + encodeURIComponent("" + model_taskProierty) + "&"; 
        if (model_attachments === undefined || model_attachments === null)
            throw new Error("The parameter 'model_attachments' must be defined and cannot be null.");
        else
            url_ += "model.attachments=" + encodeURIComponent("" + model_attachments) + "&"; 
        if (model_taskID !== undefined)
            url_ += "model.taskID=" + encodeURIComponent("" + model_taskID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLike(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperationDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperationDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLike(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperationDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskOperationDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperationDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation[]>> {
        let url_ = this.baseUrl + "/api/TaskOperations/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperation[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperation[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperation[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskOperation.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperation[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation>> {
        let url_ = this.baseUrl + "/api/TaskOperations/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperation>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperation>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperation>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TaskOperation.fromJS(resultData200, _mappings) : new TaskOperation();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperation>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, taskOperation: TaskOperationDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/TaskOperations/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(taskOperation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(taskOperation: TaskOperationDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation>> {
        let url_ = this.baseUrl + "/api/TaskOperations/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(taskOperation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperation>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperation>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperation>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TaskOperation.fromJS(resultData200, _mappings) : new TaskOperation();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperation>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskOperation>> {
        let url_ = this.baseUrl + "/api/TaskOperations/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskOperation>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskOperation>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<TaskOperation>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TaskOperation.fromJS(resultData200, _mappings) : new TaskOperation();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskOperation>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export interface ITaskTypesClient {
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskTypeDTO[]>>;
    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskTypeDTO[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType[]>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType>>;
    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, taskType: TaskTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(taskType: TaskTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType>>;
    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType>>;
}

@Injectable({
    providedIn: 'root'
})
export class TaskTypesClient implements ITaskTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ShabakAPI_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://http://4dapps.net/ShabakApi/swagger//ShabakApi";
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAllDTO(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/TaskTypes/GetAllDTO";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDTO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDTO(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDTO(response: HttpResponseBase): Observable<SwaggerResponse<TaskTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param model_iD (optional) 
     * @param authorization (optional) access token
     * @return OK
     */
    getByParams(model_arName: string, model_enName: string, model_iD?: number | null | undefined, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskTypeDTO[]>> {
        let url_ = this.baseUrl + "/api/TaskTypes/GetByParams?";
        if (model_arName === undefined || model_arName === null)
            throw new Error("The parameter 'model_arName' must be defined and cannot be null.");
        else
            url_ += "model.arName=" + encodeURIComponent("" + model_arName) + "&"; 
        if (model_enName === undefined || model_enName === null)
            throw new Error("The parameter 'model_enName' must be defined and cannot be null.");
        else
            url_ += "model.enName=" + encodeURIComponent("" + model_enName) + "&"; 
        if (model_iD !== undefined)
            url_ += "model.iD=" + encodeURIComponent("" + model_iD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParams(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskTypeDTO[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskTypeDTO[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParams(response: HttpResponseBase): Observable<SwaggerResponse<TaskTypeDTO[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskTypeDTO.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskTypeDTO[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getAll(authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType[]>> {
        let url_ = this.baseUrl + "/api/TaskTypes/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskType[]>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskType[]>>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SwaggerResponse<TaskType[]>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskType.fromJS(item, _mappings));
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskType[]>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    getByID(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType>> {
        let url_ = this.baseUrl + "/api/TaskTypes/GetByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskType>>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<SwaggerResponse<TaskType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TaskType.fromJS(resultData200, _mappings) : new TaskType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return No Content
     */
    update(id: number, taskType: TaskTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/TaskTypes/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(taskType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<void>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<void>>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    add(taskType: TaskTypeDTO, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType>> {
        let url_ = this.baseUrl + "/api/TaskTypes/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(taskType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskType>>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<SwaggerResponse<TaskType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TaskType.fromJS(resultData200, _mappings) : new TaskType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskType>>(new SwaggerResponse(status, _headers, <any>null));
    }

    /**
     * @param authorization (optional) access token
     * @return OK
     */
    delete(id: number, authorization?: string | null | undefined): Observable<SwaggerResponse<TaskType>> {
        let url_ = this.baseUrl + "/api/TaskTypes/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SwaggerResponse<TaskType>>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwaggerResponse<TaskType>>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SwaggerResponse<TaskType>> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TaskType.fromJS(resultData200, _mappings) : new TaskType();
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TaskType>>(new SwaggerResponse(status, _headers, <any>null));
    }
}

export class ActionTBLDTO implements IActionTBLDTO {
    iD?: number | null;
    employeeActionID!: number;
    actionTaken!: number;
    actionDate!: Date;
    notes?: string | null;
    attachments!: string;

    constructor(data?: IActionTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.employeeActionID = data["EmployeeActionID"] !== undefined ? data["EmployeeActionID"] : <any>null;
            this.actionTaken = data["ActionTaken"] !== undefined ? data["ActionTaken"] : <any>null;
            this.actionDate = data["ActionDate"] ? new Date(data["ActionDate"].toString()) : <any>null;
            this.notes = data["Notes"] !== undefined ? data["Notes"] : <any>null;
            this.attachments = data["Attachments"] !== undefined ? data["Attachments"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ActionTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionTBLDTO>(data, _mappings, ActionTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["EmployeeActionID"] = this.employeeActionID !== undefined ? this.employeeActionID : <any>null;
        data["ActionTaken"] = this.actionTaken !== undefined ? this.actionTaken : <any>null;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>null;
        data["Notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["Attachments"] = this.attachments !== undefined ? this.attachments : <any>null;
        return data; 
    }
}

export interface IActionTBLDTO {
    iD?: number | null;
    employeeActionID: number;
    actionTaken: number;
    actionDate: Date;
    notes?: string | null;
    attachments: string;
}

export class ActionTBL implements IActionTBL {
    iD?: number | null;
    employeeActionID?: number | null;
    actionTaken?: number | null;
    actionDate?: Date | null;
    notes?: string | null;
    attachments?: string | null;
    actionType?: ActionType | null;
    employeeTask?: EmployeeTask | null;

    constructor(data?: IActionTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.employeeActionID = data["EmployeeActionID"] !== undefined ? data["EmployeeActionID"] : <any>null;
            this.actionTaken = data["ActionTaken"] !== undefined ? data["ActionTaken"] : <any>null;
            this.actionDate = data["ActionDate"] ? new Date(data["ActionDate"].toString()) : <any>null;
            this.notes = data["Notes"] !== undefined ? data["Notes"] : <any>null;
            this.attachments = data["Attachments"] !== undefined ? data["Attachments"] : <any>null;
            this.actionType = data["ActionType"] ? ActionType.fromJS(data["ActionType"], _mappings) : <any>null;
            this.employeeTask = data["EmployeeTask"] ? EmployeeTask.fromJS(data["EmployeeTask"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ActionTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionTBL>(data, _mappings, ActionTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["EmployeeActionID"] = this.employeeActionID !== undefined ? this.employeeActionID : <any>null;
        data["ActionTaken"] = this.actionTaken !== undefined ? this.actionTaken : <any>null;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>null;
        data["Notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["Attachments"] = this.attachments !== undefined ? this.attachments : <any>null;
        data["ActionType"] = this.actionType ? this.actionType.toJSON() : <any>null;
        data["EmployeeTask"] = this.employeeTask ? this.employeeTask.toJSON() : <any>null;
        return data; 
    }
}

export interface IActionTBL {
    iD?: number | null;
    employeeActionID?: number | null;
    actionTaken?: number | null;
    actionDate?: Date | null;
    notes?: string | null;
    attachments?: string | null;
    actionType?: ActionType | null;
    employeeTask?: EmployeeTask | null;
}

export class ActionType implements IActionType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    percentageAdd?: number | null;
    actionTBLs?: ActionTBL[] | null;

    constructor(data?: IActionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.percentageAdd = data["PercentageAdd"] !== undefined ? data["PercentageAdd"] : <any>null;
            if (data["ActionTBLs"] && data["ActionTBLs"].constructor === Array) {
                this.actionTBLs = [] as any;
                for (let item of data["ActionTBLs"])
                    this.actionTBLs!.push(ActionTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ActionType {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionType>(data, _mappings, ActionType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["PercentageAdd"] = this.percentageAdd !== undefined ? this.percentageAdd : <any>null;
        if (this.actionTBLs && this.actionTBLs.constructor === Array) {
            data["ActionTBLs"] = [];
            for (let item of this.actionTBLs)
                data["ActionTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IActionType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    percentageAdd?: number | null;
    actionTBLs?: ActionTBL[] | null;
}

export class EmployeeTask implements IEmployeeTask {
    iD?: number | null;
    taskID?: number | null;
    empID?: number | null;
    roleInTask?: number | null;
    actionTBLs?: ActionTBL[] | null;
    roleInTask1?: RoleInTask | null;
    taskOperation?: TaskOperation | null;

    constructor(data?: IEmployeeTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.taskID = data["TaskID"] !== undefined ? data["TaskID"] : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.roleInTask = data["RoleInTask"] !== undefined ? data["RoleInTask"] : <any>null;
            if (data["ActionTBLs"] && data["ActionTBLs"].constructor === Array) {
                this.actionTBLs = [] as any;
                for (let item of data["ActionTBLs"])
                    this.actionTBLs!.push(ActionTBL.fromJS(item, _mappings));
            }
            this.roleInTask1 = data["RoleInTask1"] ? RoleInTask.fromJS(data["RoleInTask1"], _mappings) : <any>null;
            this.taskOperation = data["TaskOperation"] ? TaskOperation.fromJS(data["TaskOperation"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EmployeeTask {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployeeTask>(data, _mappings, EmployeeTask);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["TaskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["RoleInTask"] = this.roleInTask !== undefined ? this.roleInTask : <any>null;
        if (this.actionTBLs && this.actionTBLs.constructor === Array) {
            data["ActionTBLs"] = [];
            for (let item of this.actionTBLs)
                data["ActionTBLs"].push(item.toJSON());
        }
        data["RoleInTask1"] = this.roleInTask1 ? this.roleInTask1.toJSON() : <any>null;
        data["TaskOperation"] = this.taskOperation ? this.taskOperation.toJSON() : <any>null;
        return data; 
    }
}

export interface IEmployeeTask {
    iD?: number | null;
    taskID?: number | null;
    empID?: number | null;
    roleInTask?: number | null;
    actionTBLs?: ActionTBL[] | null;
    roleInTask1?: RoleInTask | null;
    taskOperation?: TaskOperation | null;
}

export class RoleInTask implements IRoleInTask {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTasks?: EmployeeTask[] | null;

    constructor(data?: IRoleInTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["EmployeeTasks"] && data["EmployeeTasks"].constructor === Array) {
                this.employeeTasks = [] as any;
                for (let item of data["EmployeeTasks"])
                    this.employeeTasks!.push(EmployeeTask.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RoleInTask {
        data = typeof data === 'object' ? data : {};
        return createInstance<RoleInTask>(data, _mappings, RoleInTask);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.employeeTasks && this.employeeTasks.constructor === Array) {
            data["EmployeeTasks"] = [];
            for (let item of this.employeeTasks)
                data["EmployeeTasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleInTask {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTasks?: EmployeeTask[] | null;
}

export class TaskOperation implements ITaskOperation {
    taskID?: number | null;
    taskName?: string | null;
    creatorEmp?: number | null;
    creationDate?: Date | null;
    startDate?: Date | null;
    endDate?: Date | null;
    parentID?: number | null;
    deliverableID?: number | null;
    taskStatus?: boolean | null;
    taskType?: number | null;
    taskProierty?: number | null;
    attachments?: string | null;
    employeeTasks?: EmployeeTask[] | null;
    proiertyType?: ProiertyType | null;
    taskOperations1?: TaskOperation[] | null;
    taskOperation1?: TaskOperation | null;
    taskType1?: TaskType | null;

    constructor(data?: ITaskOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.taskID = data["TaskID"] !== undefined ? data["TaskID"] : <any>null;
            this.taskName = data["TaskName"] !== undefined ? data["TaskName"] : <any>null;
            this.creatorEmp = data["CreatorEmp"] !== undefined ? data["CreatorEmp"] : <any>null;
            this.creationDate = data["CreationDate"] ? new Date(data["CreationDate"].toString()) : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.parentID = data["ParentID"] !== undefined ? data["ParentID"] : <any>null;
            this.deliverableID = data["DeliverableID"] !== undefined ? data["DeliverableID"] : <any>null;
            this.taskStatus = data["TaskStatus"] !== undefined ? data["TaskStatus"] : <any>null;
            this.taskType = data["TaskType"] !== undefined ? data["TaskType"] : <any>null;
            this.taskProierty = data["TaskProierty"] !== undefined ? data["TaskProierty"] : <any>null;
            this.attachments = data["Attachments"] !== undefined ? data["Attachments"] : <any>null;
            if (data["EmployeeTasks"] && data["EmployeeTasks"].constructor === Array) {
                this.employeeTasks = [] as any;
                for (let item of data["EmployeeTasks"])
                    this.employeeTasks!.push(EmployeeTask.fromJS(item, _mappings));
            }
            this.proiertyType = data["ProiertyType"] ? ProiertyType.fromJS(data["ProiertyType"], _mappings) : <any>null;
            if (data["TaskOperations1"] && data["TaskOperations1"].constructor === Array) {
                this.taskOperations1 = [] as any;
                for (let item of data["TaskOperations1"])
                    this.taskOperations1!.push(TaskOperation.fromJS(item, _mappings));
            }
            this.taskOperation1 = data["TaskOperation1"] ? TaskOperation.fromJS(data["TaskOperation1"], _mappings) : <any>null;
            this.taskType1 = data["TaskType1"] ? TaskType.fromJS(data["TaskType1"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TaskOperation {
        data = typeof data === 'object' ? data : {};
        return createInstance<TaskOperation>(data, _mappings, TaskOperation);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TaskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        data["TaskName"] = this.taskName !== undefined ? this.taskName : <any>null;
        data["CreatorEmp"] = this.creatorEmp !== undefined ? this.creatorEmp : <any>null;
        data["CreationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["ParentID"] = this.parentID !== undefined ? this.parentID : <any>null;
        data["DeliverableID"] = this.deliverableID !== undefined ? this.deliverableID : <any>null;
        data["TaskStatus"] = this.taskStatus !== undefined ? this.taskStatus : <any>null;
        data["TaskType"] = this.taskType !== undefined ? this.taskType : <any>null;
        data["TaskProierty"] = this.taskProierty !== undefined ? this.taskProierty : <any>null;
        data["Attachments"] = this.attachments !== undefined ? this.attachments : <any>null;
        if (this.employeeTasks && this.employeeTasks.constructor === Array) {
            data["EmployeeTasks"] = [];
            for (let item of this.employeeTasks)
                data["EmployeeTasks"].push(item.toJSON());
        }
        data["ProiertyType"] = this.proiertyType ? this.proiertyType.toJSON() : <any>null;
        if (this.taskOperations1 && this.taskOperations1.constructor === Array) {
            data["TaskOperations1"] = [];
            for (let item of this.taskOperations1)
                data["TaskOperations1"].push(item.toJSON());
        }
        data["TaskOperation1"] = this.taskOperation1 ? this.taskOperation1.toJSON() : <any>null;
        data["TaskType1"] = this.taskType1 ? this.taskType1.toJSON() : <any>null;
        return data; 
    }
}

export interface ITaskOperation {
    taskID?: number | null;
    taskName?: string | null;
    creatorEmp?: number | null;
    creationDate?: Date | null;
    startDate?: Date | null;
    endDate?: Date | null;
    parentID?: number | null;
    deliverableID?: number | null;
    taskStatus?: boolean | null;
    taskType?: number | null;
    taskProierty?: number | null;
    attachments?: string | null;
    employeeTasks?: EmployeeTask[] | null;
    proiertyType?: ProiertyType | null;
    taskOperations1?: TaskOperation[] | null;
    taskOperation1?: TaskOperation | null;
    taskType1?: TaskType | null;
}

export class ProiertyType implements IProiertyType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    taskOperations?: TaskOperation[] | null;

    constructor(data?: IProiertyType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["TaskOperations"] && data["TaskOperations"].constructor === Array) {
                this.taskOperations = [] as any;
                for (let item of data["TaskOperations"])
                    this.taskOperations!.push(TaskOperation.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ProiertyType {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProiertyType>(data, _mappings, ProiertyType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.taskOperations && this.taskOperations.constructor === Array) {
            data["TaskOperations"] = [];
            for (let item of this.taskOperations)
                data["TaskOperations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProiertyType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    taskOperations?: TaskOperation[] | null;
}

export class TaskType implements ITaskType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    taskOperations?: TaskOperation[] | null;

    constructor(data?: ITaskType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["TaskOperations"] && data["TaskOperations"].constructor === Array) {
                this.taskOperations = [] as any;
                for (let item of data["TaskOperations"])
                    this.taskOperations!.push(TaskOperation.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): TaskType {
        data = typeof data === 'object' ? data : {};
        return createInstance<TaskType>(data, _mappings, TaskType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.taskOperations && this.taskOperations.constructor === Array) {
            data["TaskOperations"] = [];
            for (let item of this.taskOperations)
                data["TaskOperations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITaskType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    taskOperations?: TaskOperation[] | null;
}

export class ActionTypeDTO implements IActionTypeDTO {
    iD?: number | null;
    arName!: string;
    enName!: string;
    percentageAdd!: number;

    constructor(data?: IActionTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.percentageAdd = data["PercentageAdd"] !== undefined ? data["PercentageAdd"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ActionTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionTypeDTO>(data, _mappings, ActionTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["PercentageAdd"] = this.percentageAdd !== undefined ? this.percentageAdd : <any>null;
        return data; 
    }
}

export interface IActionTypeDTO {
    iD?: number | null;
    arName: string;
    enName: string;
    percentageAdd: number;
}

export class ArchiveTBLDTO implements IArchiveTBLDTO {
    iD?: number | null;
    details?: string | null;
    projectID?: number | null;
    documentType?: number | null;
    filePathLink?: string | null;
    addDate?: Date | null;
    withHardCopy?: boolean | null;

    constructor(data?: IArchiveTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.details = data["Details"] !== undefined ? data["Details"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.documentType = data["DocumentType"] !== undefined ? data["DocumentType"] : <any>null;
            this.filePathLink = data["FilePathLink"] !== undefined ? data["FilePathLink"] : <any>null;
            this.addDate = data["AddDate"] ? new Date(data["AddDate"].toString()) : <any>null;
            this.withHardCopy = data["WithHardCopy"] !== undefined ? data["WithHardCopy"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ArchiveTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ArchiveTBLDTO>(data, _mappings, ArchiveTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["Details"] = this.details !== undefined ? this.details : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["DocumentType"] = this.documentType !== undefined ? this.documentType : <any>null;
        data["FilePathLink"] = this.filePathLink !== undefined ? this.filePathLink : <any>null;
        data["AddDate"] = this.addDate ? this.addDate.toISOString() : <any>null;
        data["WithHardCopy"] = this.withHardCopy !== undefined ? this.withHardCopy : <any>null;
        return data; 
    }
}

export interface IArchiveTBLDTO {
    iD?: number | null;
    details?: string | null;
    projectID?: number | null;
    documentType?: number | null;
    filePathLink?: string | null;
    addDate?: Date | null;
    withHardCopy?: boolean | null;
}

export class ArchiveTBL implements IArchiveTBL {
    iD?: number | null;
    details?: string | null;
    projectID?: number | null;
    documentType?: number | null;
    filePathLink?: string | null;
    addDate?: Date | null;
    withHardCopy?: boolean | null;
    documentType1?: DocumentType | null;
    followUpDocumentsCircles?: FollowUpDocumentsCircle[] | null;

    constructor(data?: IArchiveTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.details = data["Details"] !== undefined ? data["Details"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.documentType = data["DocumentType"] !== undefined ? data["DocumentType"] : <any>null;
            this.filePathLink = data["FilePathLink"] !== undefined ? data["FilePathLink"] : <any>null;
            this.addDate = data["AddDate"] ? new Date(data["AddDate"].toString()) : <any>null;
            this.withHardCopy = data["WithHardCopy"] !== undefined ? data["WithHardCopy"] : <any>null;
            this.documentType1 = data["DocumentType1"] ? DocumentType.fromJS(data["DocumentType1"], _mappings) : <any>null;
            if (data["FollowUpDocumentsCircles"] && data["FollowUpDocumentsCircles"].constructor === Array) {
                this.followUpDocumentsCircles = [] as any;
                for (let item of data["FollowUpDocumentsCircles"])
                    this.followUpDocumentsCircles!.push(FollowUpDocumentsCircle.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ArchiveTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<ArchiveTBL>(data, _mappings, ArchiveTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["Details"] = this.details !== undefined ? this.details : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["DocumentType"] = this.documentType !== undefined ? this.documentType : <any>null;
        data["FilePathLink"] = this.filePathLink !== undefined ? this.filePathLink : <any>null;
        data["AddDate"] = this.addDate ? this.addDate.toISOString() : <any>null;
        data["WithHardCopy"] = this.withHardCopy !== undefined ? this.withHardCopy : <any>null;
        data["DocumentType1"] = this.documentType1 ? this.documentType1.toJSON() : <any>null;
        if (this.followUpDocumentsCircles && this.followUpDocumentsCircles.constructor === Array) {
            data["FollowUpDocumentsCircles"] = [];
            for (let item of this.followUpDocumentsCircles)
                data["FollowUpDocumentsCircles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IArchiveTBL {
    iD?: number | null;
    details?: string | null;
    projectID?: number | null;
    documentType?: number | null;
    filePathLink?: string | null;
    addDate?: Date | null;
    withHardCopy?: boolean | null;
    documentType1?: DocumentType | null;
    followUpDocumentsCircles?: FollowUpDocumentsCircle[] | null;
}

export class DocumentType implements IDocumentType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    archiveTBLs?: ArchiveTBL[] | null;

    constructor(data?: IDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["ArchiveTBLs"] && data["ArchiveTBLs"].constructor === Array) {
                this.archiveTBLs = [] as any;
                for (let item of data["ArchiveTBLs"])
                    this.archiveTBLs!.push(ArchiveTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentType {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentType>(data, _mappings, DocumentType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.archiveTBLs && this.archiveTBLs.constructor === Array) {
            data["ArchiveTBLs"] = [];
            for (let item of this.archiveTBLs)
                data["ArchiveTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDocumentType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    archiveTBLs?: ArchiveTBL[] | null;
}

export class FollowUpDocumentsCircle implements IFollowUpDocumentsCircle {
    archiveID?: number | null;
    eventDatetime?: Date | null;
    empID?: number | null;
    eventType?: number | null;
    archiveTBL?: ArchiveTBL | null;
    eventType1?: EventType | null;

    constructor(data?: IFollowUpDocumentsCircle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.archiveID = data["ArchiveID"] !== undefined ? data["ArchiveID"] : <any>null;
            this.eventDatetime = data["EventDatetime"] ? new Date(data["EventDatetime"].toString()) : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.eventType = data["EventType"] !== undefined ? data["EventType"] : <any>null;
            this.archiveTBL = data["ArchiveTBL"] ? ArchiveTBL.fromJS(data["ArchiveTBL"], _mappings) : <any>null;
            this.eventType1 = data["EventType1"] ? EventType.fromJS(data["EventType1"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FollowUpDocumentsCircle {
        data = typeof data === 'object' ? data : {};
        return createInstance<FollowUpDocumentsCircle>(data, _mappings, FollowUpDocumentsCircle);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArchiveID"] = this.archiveID !== undefined ? this.archiveID : <any>null;
        data["EventDatetime"] = this.eventDatetime ? this.eventDatetime.toISOString() : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["EventType"] = this.eventType !== undefined ? this.eventType : <any>null;
        data["ArchiveTBL"] = this.archiveTBL ? this.archiveTBL.toJSON() : <any>null;
        data["EventType1"] = this.eventType1 ? this.eventType1.toJSON() : <any>null;
        return data; 
    }
}

export interface IFollowUpDocumentsCircle {
    archiveID?: number | null;
    eventDatetime?: Date | null;
    empID?: number | null;
    eventType?: number | null;
    archiveTBL?: ArchiveTBL | null;
    eventType1?: EventType | null;
}

export class EventType implements IEventType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    followUpDocumentsCircles?: FollowUpDocumentsCircle[] | null;

    constructor(data?: IEventType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["FollowUpDocumentsCircles"] && data["FollowUpDocumentsCircles"].constructor === Array) {
                this.followUpDocumentsCircles = [] as any;
                for (let item of data["FollowUpDocumentsCircles"])
                    this.followUpDocumentsCircles!.push(FollowUpDocumentsCircle.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): EventType {
        data = typeof data === 'object' ? data : {};
        return createInstance<EventType>(data, _mappings, EventType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.followUpDocumentsCircles && this.followUpDocumentsCircles.constructor === Array) {
            data["FollowUpDocumentsCircles"] = [];
            for (let item of this.followUpDocumentsCircles)
                data["FollowUpDocumentsCircles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEventType {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    followUpDocumentsCircles?: FollowUpDocumentsCircle[] | null;
}

export class ContractsChangeDTO implements IContractsChangeDTO {
    iD?: number | null;
    projectID!: number;
    changedDescription!: string;
    originalAmount?: number | null;
    newAmount?: number | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;

    constructor(data?: IContractsChangeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.changedDescription = data["ChangedDescription"] !== undefined ? data["ChangedDescription"] : <any>null;
            this.originalAmount = data["OriginalAmount"] !== undefined ? data["OriginalAmount"] : <any>null;
            this.newAmount = data["NewAmount"] !== undefined ? data["NewAmount"] : <any>null;
            this.projectTBLProjectID = data["ProjectTBLProjectID"] !== undefined ? data["ProjectTBLProjectID"] : <any>null;
            this.projectTBLProjectNumber = data["ProjectTBLProjectNumber"] !== undefined ? data["ProjectTBLProjectNumber"] : <any>null;
            this.projectTBLArName = data["ProjectTBLArName"] !== undefined ? data["ProjectTBLArName"] : <any>null;
            this.projectTBLEnName = data["ProjectTBLEnName"] !== undefined ? data["ProjectTBLEnName"] : <any>null;
            this.projectTBLStartDate = data["ProjectTBLStartDate"] ? new Date(data["ProjectTBLStartDate"].toString()) : <any>null;
            this.projectTBLMainContractAmount = data["ProjectTBLMainContractAmount"] !== undefined ? data["ProjectTBLMainContractAmount"] : <any>null;
            this.projectTBLEndDate = data["ProjectTBLEndDate"] ? new Date(data["ProjectTBLEndDate"].toString()) : <any>null;
            this.projectTBLIsActiveProject = data["ProjectTBLIsActiveProject"] !== undefined ? data["ProjectTBLIsActiveProject"] : <any>null;
            if (data["ProjectTBLContractsChanges"] && data["ProjectTBLContractsChanges"].constructor === Array) {
                this.projectTBLContractsChanges = [] as any;
                for (let item of data["ProjectTBLContractsChanges"])
                    this.projectTBLContractsChanges!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLOrganizationsProjects"] && data["ProjectTBLOrganizationsProjects"].constructor === Array) {
                this.projectTBLOrganizationsProjects = [] as any;
                for (let item of data["ProjectTBLOrganizationsProjects"])
                    this.projectTBLOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLProjectEmployees"] && data["ProjectTBLProjectEmployees"].constructor === Array) {
                this.projectTBLProjectEmployees = [] as any;
                for (let item of data["ProjectTBLProjectEmployees"])
                    this.projectTBLProjectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLStageProjects"] && data["ProjectTBLStageProjects"].constructor === Array) {
                this.projectTBLStageProjects = [] as any;
                for (let item of data["ProjectTBLStageProjects"])
                    this.projectTBLStageProjects!.push(StageProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ContractsChangeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ContractsChangeDTO>(data, _mappings, ContractsChangeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["ChangedDescription"] = this.changedDescription !== undefined ? this.changedDescription : <any>null;
        data["OriginalAmount"] = this.originalAmount !== undefined ? this.originalAmount : <any>null;
        data["NewAmount"] = this.newAmount !== undefined ? this.newAmount : <any>null;
        data["ProjectTBLProjectID"] = this.projectTBLProjectID !== undefined ? this.projectTBLProjectID : <any>null;
        data["ProjectTBLProjectNumber"] = this.projectTBLProjectNumber !== undefined ? this.projectTBLProjectNumber : <any>null;
        data["ProjectTBLArName"] = this.projectTBLArName !== undefined ? this.projectTBLArName : <any>null;
        data["ProjectTBLEnName"] = this.projectTBLEnName !== undefined ? this.projectTBLEnName : <any>null;
        data["ProjectTBLStartDate"] = this.projectTBLStartDate ? this.projectTBLStartDate.toISOString() : <any>null;
        data["ProjectTBLMainContractAmount"] = this.projectTBLMainContractAmount !== undefined ? this.projectTBLMainContractAmount : <any>null;
        data["ProjectTBLEndDate"] = this.projectTBLEndDate ? this.projectTBLEndDate.toISOString() : <any>null;
        data["ProjectTBLIsActiveProject"] = this.projectTBLIsActiveProject !== undefined ? this.projectTBLIsActiveProject : <any>null;
        if (this.projectTBLContractsChanges && this.projectTBLContractsChanges.constructor === Array) {
            data["ProjectTBLContractsChanges"] = [];
            for (let item of this.projectTBLContractsChanges)
                data["ProjectTBLContractsChanges"].push(item.toJSON());
        }
        if (this.projectTBLOrganizationsProjects && this.projectTBLOrganizationsProjects.constructor === Array) {
            data["ProjectTBLOrganizationsProjects"] = [];
            for (let item of this.projectTBLOrganizationsProjects)
                data["ProjectTBLOrganizationsProjects"].push(item.toJSON());
        }
        if (this.projectTBLProjectEmployees && this.projectTBLProjectEmployees.constructor === Array) {
            data["ProjectTBLProjectEmployees"] = [];
            for (let item of this.projectTBLProjectEmployees)
                data["ProjectTBLProjectEmployees"].push(item.toJSON());
        }
        if (this.projectTBLStageProjects && this.projectTBLStageProjects.constructor === Array) {
            data["ProjectTBLStageProjects"] = [];
            for (let item of this.projectTBLStageProjects)
                data["ProjectTBLStageProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContractsChangeDTO {
    iD?: number | null;
    projectID: number;
    changedDescription: string;
    originalAmount?: number | null;
    newAmount?: number | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;
}

export class OrganizationsProjectDTO implements IOrganizationsProjectDTO {
    serNum?: number | null;
    peopleID!: number;
    projectID!: number;
    orgTypeID!: number;
    oegTypeOrgTypeID?: number | null;
    oegTypeTypeArName?: string | null;
    oegTypeTypeEnName?: string | null;
    oegTypeOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    pepoleTBLPeopleID?: number | null;
    pepoleTBLArName?: string | null;
    pepoleTBLEnName?: string | null;
    pepoleTBLMobilePhone?: string | null;
    pepoleTBLLandLineExt?: string | null;
    pepoleTBLEmailAdress?: string | null;
    pepoleTBLOrgID?: number | null;
    pepoleTBLOrganizationBasicOrgID?: number | null;
    pepoleTBLOrganizationBasicOrgArName?: string | null;
    pepoleTBLOrganizationBasicOrgEnName?: string | null;
    pepoleTBLOrganizationBasicLandLineNumber?: string | null;
    pepoleTBLOrganizationBasicPepoleTBLs?: PepoleTBLDTO[] | null;
    pepoleTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;

    constructor(data?: IOrganizationsProjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.serNum = data["SerNum"] !== undefined ? data["SerNum"] : <any>null;
            this.peopleID = data["PeopleID"] !== undefined ? data["PeopleID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.orgTypeID = data["OrgTypeID"] !== undefined ? data["OrgTypeID"] : <any>null;
            this.oegTypeOrgTypeID = data["OegTypeOrgTypeID"] !== undefined ? data["OegTypeOrgTypeID"] : <any>null;
            this.oegTypeTypeArName = data["OegTypeTypeArName"] !== undefined ? data["OegTypeTypeArName"] : <any>null;
            this.oegTypeTypeEnName = data["OegTypeTypeEnName"] !== undefined ? data["OegTypeTypeEnName"] : <any>null;
            if (data["OegTypeOrganizationsProjects"] && data["OegTypeOrganizationsProjects"].constructor === Array) {
                this.oegTypeOrganizationsProjects = [] as any;
                for (let item of data["OegTypeOrganizationsProjects"])
                    this.oegTypeOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            this.pepoleTBLPeopleID = data["PepoleTBLPeopleID"] !== undefined ? data["PepoleTBLPeopleID"] : <any>null;
            this.pepoleTBLArName = data["PepoleTBLArName"] !== undefined ? data["PepoleTBLArName"] : <any>null;
            this.pepoleTBLEnName = data["PepoleTBLEnName"] !== undefined ? data["PepoleTBLEnName"] : <any>null;
            this.pepoleTBLMobilePhone = data["PepoleTBLMobilePhone"] !== undefined ? data["PepoleTBLMobilePhone"] : <any>null;
            this.pepoleTBLLandLineExt = data["PepoleTBLLandLineExt"] !== undefined ? data["PepoleTBLLandLineExt"] : <any>null;
            this.pepoleTBLEmailAdress = data["PepoleTBLEmailAdress"] !== undefined ? data["PepoleTBLEmailAdress"] : <any>null;
            this.pepoleTBLOrgID = data["PepoleTBLOrgID"] !== undefined ? data["PepoleTBLOrgID"] : <any>null;
            this.pepoleTBLOrganizationBasicOrgID = data["PepoleTBLOrganizationBasicOrgID"] !== undefined ? data["PepoleTBLOrganizationBasicOrgID"] : <any>null;
            this.pepoleTBLOrganizationBasicOrgArName = data["PepoleTBLOrganizationBasicOrgArName"] !== undefined ? data["PepoleTBLOrganizationBasicOrgArName"] : <any>null;
            this.pepoleTBLOrganizationBasicOrgEnName = data["PepoleTBLOrganizationBasicOrgEnName"] !== undefined ? data["PepoleTBLOrganizationBasicOrgEnName"] : <any>null;
            this.pepoleTBLOrganizationBasicLandLineNumber = data["PepoleTBLOrganizationBasicLandLineNumber"] !== undefined ? data["PepoleTBLOrganizationBasicLandLineNumber"] : <any>null;
            if (data["PepoleTBLOrganizationBasicPepoleTBLs"] && data["PepoleTBLOrganizationBasicPepoleTBLs"].constructor === Array) {
                this.pepoleTBLOrganizationBasicPepoleTBLs = [] as any;
                for (let item of data["PepoleTBLOrganizationBasicPepoleTBLs"])
                    this.pepoleTBLOrganizationBasicPepoleTBLs!.push(PepoleTBLDTO.fromJS(item, _mappings));
            }
            if (data["PepoleTBLOrganizationsProjects"] && data["PepoleTBLOrganizationsProjects"].constructor === Array) {
                this.pepoleTBLOrganizationsProjects = [] as any;
                for (let item of data["PepoleTBLOrganizationsProjects"])
                    this.pepoleTBLOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            this.projectTBLProjectID = data["ProjectTBLProjectID"] !== undefined ? data["ProjectTBLProjectID"] : <any>null;
            this.projectTBLProjectNumber = data["ProjectTBLProjectNumber"] !== undefined ? data["ProjectTBLProjectNumber"] : <any>null;
            this.projectTBLArName = data["ProjectTBLArName"] !== undefined ? data["ProjectTBLArName"] : <any>null;
            this.projectTBLEnName = data["ProjectTBLEnName"] !== undefined ? data["ProjectTBLEnName"] : <any>null;
            this.projectTBLStartDate = data["ProjectTBLStartDate"] ? new Date(data["ProjectTBLStartDate"].toString()) : <any>null;
            this.projectTBLMainContractAmount = data["ProjectTBLMainContractAmount"] !== undefined ? data["ProjectTBLMainContractAmount"] : <any>null;
            this.projectTBLEndDate = data["ProjectTBLEndDate"] ? new Date(data["ProjectTBLEndDate"].toString()) : <any>null;
            this.projectTBLIsActiveProject = data["ProjectTBLIsActiveProject"] !== undefined ? data["ProjectTBLIsActiveProject"] : <any>null;
            if (data["ProjectTBLContractsChanges"] && data["ProjectTBLContractsChanges"].constructor === Array) {
                this.projectTBLContractsChanges = [] as any;
                for (let item of data["ProjectTBLContractsChanges"])
                    this.projectTBLContractsChanges!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLOrganizationsProjects"] && data["ProjectTBLOrganizationsProjects"].constructor === Array) {
                this.projectTBLOrganizationsProjects = [] as any;
                for (let item of data["ProjectTBLOrganizationsProjects"])
                    this.projectTBLOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLProjectEmployees"] && data["ProjectTBLProjectEmployees"].constructor === Array) {
                this.projectTBLProjectEmployees = [] as any;
                for (let item of data["ProjectTBLProjectEmployees"])
                    this.projectTBLProjectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLStageProjects"] && data["ProjectTBLStageProjects"].constructor === Array) {
                this.projectTBLStageProjects = [] as any;
                for (let item of data["ProjectTBLStageProjects"])
                    this.projectTBLStageProjects!.push(StageProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OrganizationsProjectDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrganizationsProjectDTO>(data, _mappings, OrganizationsProjectDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SerNum"] = this.serNum !== undefined ? this.serNum : <any>null;
        data["PeopleID"] = this.peopleID !== undefined ? this.peopleID : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["OrgTypeID"] = this.orgTypeID !== undefined ? this.orgTypeID : <any>null;
        data["OegTypeOrgTypeID"] = this.oegTypeOrgTypeID !== undefined ? this.oegTypeOrgTypeID : <any>null;
        data["OegTypeTypeArName"] = this.oegTypeTypeArName !== undefined ? this.oegTypeTypeArName : <any>null;
        data["OegTypeTypeEnName"] = this.oegTypeTypeEnName !== undefined ? this.oegTypeTypeEnName : <any>null;
        if (this.oegTypeOrganizationsProjects && this.oegTypeOrganizationsProjects.constructor === Array) {
            data["OegTypeOrganizationsProjects"] = [];
            for (let item of this.oegTypeOrganizationsProjects)
                data["OegTypeOrganizationsProjects"].push(item.toJSON());
        }
        data["PepoleTBLPeopleID"] = this.pepoleTBLPeopleID !== undefined ? this.pepoleTBLPeopleID : <any>null;
        data["PepoleTBLArName"] = this.pepoleTBLArName !== undefined ? this.pepoleTBLArName : <any>null;
        data["PepoleTBLEnName"] = this.pepoleTBLEnName !== undefined ? this.pepoleTBLEnName : <any>null;
        data["PepoleTBLMobilePhone"] = this.pepoleTBLMobilePhone !== undefined ? this.pepoleTBLMobilePhone : <any>null;
        data["PepoleTBLLandLineExt"] = this.pepoleTBLLandLineExt !== undefined ? this.pepoleTBLLandLineExt : <any>null;
        data["PepoleTBLEmailAdress"] = this.pepoleTBLEmailAdress !== undefined ? this.pepoleTBLEmailAdress : <any>null;
        data["PepoleTBLOrgID"] = this.pepoleTBLOrgID !== undefined ? this.pepoleTBLOrgID : <any>null;
        data["PepoleTBLOrganizationBasicOrgID"] = this.pepoleTBLOrganizationBasicOrgID !== undefined ? this.pepoleTBLOrganizationBasicOrgID : <any>null;
        data["PepoleTBLOrganizationBasicOrgArName"] = this.pepoleTBLOrganizationBasicOrgArName !== undefined ? this.pepoleTBLOrganizationBasicOrgArName : <any>null;
        data["PepoleTBLOrganizationBasicOrgEnName"] = this.pepoleTBLOrganizationBasicOrgEnName !== undefined ? this.pepoleTBLOrganizationBasicOrgEnName : <any>null;
        data["PepoleTBLOrganizationBasicLandLineNumber"] = this.pepoleTBLOrganizationBasicLandLineNumber !== undefined ? this.pepoleTBLOrganizationBasicLandLineNumber : <any>null;
        if (this.pepoleTBLOrganizationBasicPepoleTBLs && this.pepoleTBLOrganizationBasicPepoleTBLs.constructor === Array) {
            data["PepoleTBLOrganizationBasicPepoleTBLs"] = [];
            for (let item of this.pepoleTBLOrganizationBasicPepoleTBLs)
                data["PepoleTBLOrganizationBasicPepoleTBLs"].push(item.toJSON());
        }
        if (this.pepoleTBLOrganizationsProjects && this.pepoleTBLOrganizationsProjects.constructor === Array) {
            data["PepoleTBLOrganizationsProjects"] = [];
            for (let item of this.pepoleTBLOrganizationsProjects)
                data["PepoleTBLOrganizationsProjects"].push(item.toJSON());
        }
        data["ProjectTBLProjectID"] = this.projectTBLProjectID !== undefined ? this.projectTBLProjectID : <any>null;
        data["ProjectTBLProjectNumber"] = this.projectTBLProjectNumber !== undefined ? this.projectTBLProjectNumber : <any>null;
        data["ProjectTBLArName"] = this.projectTBLArName !== undefined ? this.projectTBLArName : <any>null;
        data["ProjectTBLEnName"] = this.projectTBLEnName !== undefined ? this.projectTBLEnName : <any>null;
        data["ProjectTBLStartDate"] = this.projectTBLStartDate ? this.projectTBLStartDate.toISOString() : <any>null;
        data["ProjectTBLMainContractAmount"] = this.projectTBLMainContractAmount !== undefined ? this.projectTBLMainContractAmount : <any>null;
        data["ProjectTBLEndDate"] = this.projectTBLEndDate ? this.projectTBLEndDate.toISOString() : <any>null;
        data["ProjectTBLIsActiveProject"] = this.projectTBLIsActiveProject !== undefined ? this.projectTBLIsActiveProject : <any>null;
        if (this.projectTBLContractsChanges && this.projectTBLContractsChanges.constructor === Array) {
            data["ProjectTBLContractsChanges"] = [];
            for (let item of this.projectTBLContractsChanges)
                data["ProjectTBLContractsChanges"].push(item.toJSON());
        }
        if (this.projectTBLOrganizationsProjects && this.projectTBLOrganizationsProjects.constructor === Array) {
            data["ProjectTBLOrganizationsProjects"] = [];
            for (let item of this.projectTBLOrganizationsProjects)
                data["ProjectTBLOrganizationsProjects"].push(item.toJSON());
        }
        if (this.projectTBLProjectEmployees && this.projectTBLProjectEmployees.constructor === Array) {
            data["ProjectTBLProjectEmployees"] = [];
            for (let item of this.projectTBLProjectEmployees)
                data["ProjectTBLProjectEmployees"].push(item.toJSON());
        }
        if (this.projectTBLStageProjects && this.projectTBLStageProjects.constructor === Array) {
            data["ProjectTBLStageProjects"] = [];
            for (let item of this.projectTBLStageProjects)
                data["ProjectTBLStageProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationsProjectDTO {
    serNum?: number | null;
    peopleID: number;
    projectID: number;
    orgTypeID: number;
    oegTypeOrgTypeID?: number | null;
    oegTypeTypeArName?: string | null;
    oegTypeTypeEnName?: string | null;
    oegTypeOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    pepoleTBLPeopleID?: number | null;
    pepoleTBLArName?: string | null;
    pepoleTBLEnName?: string | null;
    pepoleTBLMobilePhone?: string | null;
    pepoleTBLLandLineExt?: string | null;
    pepoleTBLEmailAdress?: string | null;
    pepoleTBLOrgID?: number | null;
    pepoleTBLOrganizationBasicOrgID?: number | null;
    pepoleTBLOrganizationBasicOrgArName?: string | null;
    pepoleTBLOrganizationBasicOrgEnName?: string | null;
    pepoleTBLOrganizationBasicLandLineNumber?: string | null;
    pepoleTBLOrganizationBasicPepoleTBLs?: PepoleTBLDTO[] | null;
    pepoleTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;
}

export class ProjectEmployeeDTO implements IProjectEmployeeDTO {
    iD?: number | null;
    projectID!: number;
    empID!: number;
    startFrom!: Date;
    endTo!: Date;
    positionInProject!: number;
    positionInProject1ID?: number | null;
    positionInProject1ArName?: string | null;
    positionInProject1EnName?: string | null;
    positionInProject1ProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;

    constructor(data?: IProjectEmployeeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.startFrom = data["StartFrom"] ? new Date(data["StartFrom"].toString()) : <any>null;
            this.endTo = data["EndTo"] ? new Date(data["EndTo"].toString()) : <any>null;
            this.positionInProject = data["PositionInProject"] !== undefined ? data["PositionInProject"] : <any>null;
            this.positionInProject1ID = data["PositionInProject1ID"] !== undefined ? data["PositionInProject1ID"] : <any>null;
            this.positionInProject1ArName = data["PositionInProject1ArName"] !== undefined ? data["PositionInProject1ArName"] : <any>null;
            this.positionInProject1EnName = data["PositionInProject1EnName"] !== undefined ? data["PositionInProject1EnName"] : <any>null;
            if (data["PositionInProject1ProjectEmployees"] && data["PositionInProject1ProjectEmployees"].constructor === Array) {
                this.positionInProject1ProjectEmployees = [] as any;
                for (let item of data["PositionInProject1ProjectEmployees"])
                    this.positionInProject1ProjectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            this.projectTBLProjectID = data["ProjectTBLProjectID"] !== undefined ? data["ProjectTBLProjectID"] : <any>null;
            this.projectTBLProjectNumber = data["ProjectTBLProjectNumber"] !== undefined ? data["ProjectTBLProjectNumber"] : <any>null;
            this.projectTBLArName = data["ProjectTBLArName"] !== undefined ? data["ProjectTBLArName"] : <any>null;
            this.projectTBLEnName = data["ProjectTBLEnName"] !== undefined ? data["ProjectTBLEnName"] : <any>null;
            this.projectTBLStartDate = data["ProjectTBLStartDate"] ? new Date(data["ProjectTBLStartDate"].toString()) : <any>null;
            this.projectTBLMainContractAmount = data["ProjectTBLMainContractAmount"] !== undefined ? data["ProjectTBLMainContractAmount"] : <any>null;
            this.projectTBLEndDate = data["ProjectTBLEndDate"] ? new Date(data["ProjectTBLEndDate"].toString()) : <any>null;
            this.projectTBLIsActiveProject = data["ProjectTBLIsActiveProject"] !== undefined ? data["ProjectTBLIsActiveProject"] : <any>null;
            if (data["ProjectTBLContractsChanges"] && data["ProjectTBLContractsChanges"].constructor === Array) {
                this.projectTBLContractsChanges = [] as any;
                for (let item of data["ProjectTBLContractsChanges"])
                    this.projectTBLContractsChanges!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLOrganizationsProjects"] && data["ProjectTBLOrganizationsProjects"].constructor === Array) {
                this.projectTBLOrganizationsProjects = [] as any;
                for (let item of data["ProjectTBLOrganizationsProjects"])
                    this.projectTBLOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLProjectEmployees"] && data["ProjectTBLProjectEmployees"].constructor === Array) {
                this.projectTBLProjectEmployees = [] as any;
                for (let item of data["ProjectTBLProjectEmployees"])
                    this.projectTBLProjectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLStageProjects"] && data["ProjectTBLStageProjects"].constructor === Array) {
                this.projectTBLStageProjects = [] as any;
                for (let item of data["ProjectTBLStageProjects"])
                    this.projectTBLStageProjects!.push(StageProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ProjectEmployeeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProjectEmployeeDTO>(data, _mappings, ProjectEmployeeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["StartFrom"] = this.startFrom ? this.startFrom.toISOString() : <any>null;
        data["EndTo"] = this.endTo ? this.endTo.toISOString() : <any>null;
        data["PositionInProject"] = this.positionInProject !== undefined ? this.positionInProject : <any>null;
        data["PositionInProject1ID"] = this.positionInProject1ID !== undefined ? this.positionInProject1ID : <any>null;
        data["PositionInProject1ArName"] = this.positionInProject1ArName !== undefined ? this.positionInProject1ArName : <any>null;
        data["PositionInProject1EnName"] = this.positionInProject1EnName !== undefined ? this.positionInProject1EnName : <any>null;
        if (this.positionInProject1ProjectEmployees && this.positionInProject1ProjectEmployees.constructor === Array) {
            data["PositionInProject1ProjectEmployees"] = [];
            for (let item of this.positionInProject1ProjectEmployees)
                data["PositionInProject1ProjectEmployees"].push(item.toJSON());
        }
        data["ProjectTBLProjectID"] = this.projectTBLProjectID !== undefined ? this.projectTBLProjectID : <any>null;
        data["ProjectTBLProjectNumber"] = this.projectTBLProjectNumber !== undefined ? this.projectTBLProjectNumber : <any>null;
        data["ProjectTBLArName"] = this.projectTBLArName !== undefined ? this.projectTBLArName : <any>null;
        data["ProjectTBLEnName"] = this.projectTBLEnName !== undefined ? this.projectTBLEnName : <any>null;
        data["ProjectTBLStartDate"] = this.projectTBLStartDate ? this.projectTBLStartDate.toISOString() : <any>null;
        data["ProjectTBLMainContractAmount"] = this.projectTBLMainContractAmount !== undefined ? this.projectTBLMainContractAmount : <any>null;
        data["ProjectTBLEndDate"] = this.projectTBLEndDate ? this.projectTBLEndDate.toISOString() : <any>null;
        data["ProjectTBLIsActiveProject"] = this.projectTBLIsActiveProject !== undefined ? this.projectTBLIsActiveProject : <any>null;
        if (this.projectTBLContractsChanges && this.projectTBLContractsChanges.constructor === Array) {
            data["ProjectTBLContractsChanges"] = [];
            for (let item of this.projectTBLContractsChanges)
                data["ProjectTBLContractsChanges"].push(item.toJSON());
        }
        if (this.projectTBLOrganizationsProjects && this.projectTBLOrganizationsProjects.constructor === Array) {
            data["ProjectTBLOrganizationsProjects"] = [];
            for (let item of this.projectTBLOrganizationsProjects)
                data["ProjectTBLOrganizationsProjects"].push(item.toJSON());
        }
        if (this.projectTBLProjectEmployees && this.projectTBLProjectEmployees.constructor === Array) {
            data["ProjectTBLProjectEmployees"] = [];
            for (let item of this.projectTBLProjectEmployees)
                data["ProjectTBLProjectEmployees"].push(item.toJSON());
        }
        if (this.projectTBLStageProjects && this.projectTBLStageProjects.constructor === Array) {
            data["ProjectTBLStageProjects"] = [];
            for (let item of this.projectTBLStageProjects)
                data["ProjectTBLStageProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectEmployeeDTO {
    iD?: number | null;
    projectID: number;
    empID: number;
    startFrom: Date;
    endTo: Date;
    positionInProject: number;
    positionInProject1ID?: number | null;
    positionInProject1ArName?: string | null;
    positionInProject1EnName?: string | null;
    positionInProject1ProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;
}

export class StageProjectDTO implements IStageProjectDTO {
    stageID?: number | null;
    projectID!: number;
    stageArName!: string;
    stageEnName!: string;
    startDate!: Date;
    endDate!: Date;
    stageBudget!: number;
    deliverableStages?: DeliverableStageDTO[] | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;

    constructor(data?: IStageProjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.stageID = data["StageID"] !== undefined ? data["StageID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.stageArName = data["StageArName"] !== undefined ? data["StageArName"] : <any>null;
            this.stageEnName = data["StageEnName"] !== undefined ? data["StageEnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.stageBudget = data["StageBudget"] !== undefined ? data["StageBudget"] : <any>null;
            if (data["DeliverableStages"] && data["DeliverableStages"].constructor === Array) {
                this.deliverableStages = [] as any;
                for (let item of data["DeliverableStages"])
                    this.deliverableStages!.push(DeliverableStageDTO.fromJS(item, _mappings));
            }
            this.projectTBLProjectID = data["ProjectTBLProjectID"] !== undefined ? data["ProjectTBLProjectID"] : <any>null;
            this.projectTBLProjectNumber = data["ProjectTBLProjectNumber"] !== undefined ? data["ProjectTBLProjectNumber"] : <any>null;
            this.projectTBLArName = data["ProjectTBLArName"] !== undefined ? data["ProjectTBLArName"] : <any>null;
            this.projectTBLEnName = data["ProjectTBLEnName"] !== undefined ? data["ProjectTBLEnName"] : <any>null;
            this.projectTBLStartDate = data["ProjectTBLStartDate"] ? new Date(data["ProjectTBLStartDate"].toString()) : <any>null;
            this.projectTBLMainContractAmount = data["ProjectTBLMainContractAmount"] !== undefined ? data["ProjectTBLMainContractAmount"] : <any>null;
            this.projectTBLEndDate = data["ProjectTBLEndDate"] ? new Date(data["ProjectTBLEndDate"].toString()) : <any>null;
            this.projectTBLIsActiveProject = data["ProjectTBLIsActiveProject"] !== undefined ? data["ProjectTBLIsActiveProject"] : <any>null;
            if (data["ProjectTBLContractsChanges"] && data["ProjectTBLContractsChanges"].constructor === Array) {
                this.projectTBLContractsChanges = [] as any;
                for (let item of data["ProjectTBLContractsChanges"])
                    this.projectTBLContractsChanges!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLOrganizationsProjects"] && data["ProjectTBLOrganizationsProjects"].constructor === Array) {
                this.projectTBLOrganizationsProjects = [] as any;
                for (let item of data["ProjectTBLOrganizationsProjects"])
                    this.projectTBLOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLProjectEmployees"] && data["ProjectTBLProjectEmployees"].constructor === Array) {
                this.projectTBLProjectEmployees = [] as any;
                for (let item of data["ProjectTBLProjectEmployees"])
                    this.projectTBLProjectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            if (data["ProjectTBLStageProjects"] && data["ProjectTBLStageProjects"].constructor === Array) {
                this.projectTBLStageProjects = [] as any;
                for (let item of data["ProjectTBLStageProjects"])
                    this.projectTBLStageProjects!.push(StageProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): StageProjectDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<StageProjectDTO>(data, _mappings, StageProjectDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StageID"] = this.stageID !== undefined ? this.stageID : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["StageArName"] = this.stageArName !== undefined ? this.stageArName : <any>null;
        data["StageEnName"] = this.stageEnName !== undefined ? this.stageEnName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["StageBudget"] = this.stageBudget !== undefined ? this.stageBudget : <any>null;
        if (this.deliverableStages && this.deliverableStages.constructor === Array) {
            data["DeliverableStages"] = [];
            for (let item of this.deliverableStages)
                data["DeliverableStages"].push(item.toJSON());
        }
        data["ProjectTBLProjectID"] = this.projectTBLProjectID !== undefined ? this.projectTBLProjectID : <any>null;
        data["ProjectTBLProjectNumber"] = this.projectTBLProjectNumber !== undefined ? this.projectTBLProjectNumber : <any>null;
        data["ProjectTBLArName"] = this.projectTBLArName !== undefined ? this.projectTBLArName : <any>null;
        data["ProjectTBLEnName"] = this.projectTBLEnName !== undefined ? this.projectTBLEnName : <any>null;
        data["ProjectTBLStartDate"] = this.projectTBLStartDate ? this.projectTBLStartDate.toISOString() : <any>null;
        data["ProjectTBLMainContractAmount"] = this.projectTBLMainContractAmount !== undefined ? this.projectTBLMainContractAmount : <any>null;
        data["ProjectTBLEndDate"] = this.projectTBLEndDate ? this.projectTBLEndDate.toISOString() : <any>null;
        data["ProjectTBLIsActiveProject"] = this.projectTBLIsActiveProject !== undefined ? this.projectTBLIsActiveProject : <any>null;
        if (this.projectTBLContractsChanges && this.projectTBLContractsChanges.constructor === Array) {
            data["ProjectTBLContractsChanges"] = [];
            for (let item of this.projectTBLContractsChanges)
                data["ProjectTBLContractsChanges"].push(item.toJSON());
        }
        if (this.projectTBLOrganizationsProjects && this.projectTBLOrganizationsProjects.constructor === Array) {
            data["ProjectTBLOrganizationsProjects"] = [];
            for (let item of this.projectTBLOrganizationsProjects)
                data["ProjectTBLOrganizationsProjects"].push(item.toJSON());
        }
        if (this.projectTBLProjectEmployees && this.projectTBLProjectEmployees.constructor === Array) {
            data["ProjectTBLProjectEmployees"] = [];
            for (let item of this.projectTBLProjectEmployees)
                data["ProjectTBLProjectEmployees"].push(item.toJSON());
        }
        if (this.projectTBLStageProjects && this.projectTBLStageProjects.constructor === Array) {
            data["ProjectTBLStageProjects"] = [];
            for (let item of this.projectTBLStageProjects)
                data["ProjectTBLStageProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStageProjectDTO {
    stageID?: number | null;
    projectID: number;
    stageArName: string;
    stageEnName: string;
    startDate: Date;
    endDate: Date;
    stageBudget: number;
    deliverableStages?: DeliverableStageDTO[] | null;
    projectTBLProjectID?: number | null;
    projectTBLProjectNumber?: string | null;
    projectTBLArName?: string | null;
    projectTBLEnName?: string | null;
    projectTBLStartDate?: Date | null;
    projectTBLMainContractAmount?: number | null;
    projectTBLEndDate?: Date | null;
    projectTBLIsActiveProject?: boolean | null;
    projectTBLContractsChanges?: ContractsChangeDTO[] | null;
    projectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    projectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    projectTBLStageProjects?: StageProjectDTO[] | null;
}

export class PepoleTBLDTO implements IPepoleTBLDTO {
    peopleID?: number | null;
    arName!: string;
    enName!: string;
    mobilePhone!: string;
    landLineExt!: string;
    emailAdress!: string;
    orgID?: number | null;
    organizationBasicOrgID?: number | null;
    organizationBasicOrgArName?: string | null;
    organizationBasicOrgEnName?: string | null;
    organizationBasicLandLineNumber?: string | null;
    organizationBasicPepoleTBLs?: PepoleTBLDTO[] | null;
    organizationsProjects?: OrganizationsProjectDTO[] | null;

    constructor(data?: IPepoleTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.peopleID = data["PeopleID"] !== undefined ? data["PeopleID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.mobilePhone = data["MobilePhone"] !== undefined ? data["MobilePhone"] : <any>null;
            this.landLineExt = data["LandLineExt"] !== undefined ? data["LandLineExt"] : <any>null;
            this.emailAdress = data["EmailAdress"] !== undefined ? data["EmailAdress"] : <any>null;
            this.orgID = data["OrgID"] !== undefined ? data["OrgID"] : <any>null;
            this.organizationBasicOrgID = data["OrganizationBasicOrgID"] !== undefined ? data["OrganizationBasicOrgID"] : <any>null;
            this.organizationBasicOrgArName = data["OrganizationBasicOrgArName"] !== undefined ? data["OrganizationBasicOrgArName"] : <any>null;
            this.organizationBasicOrgEnName = data["OrganizationBasicOrgEnName"] !== undefined ? data["OrganizationBasicOrgEnName"] : <any>null;
            this.organizationBasicLandLineNumber = data["OrganizationBasicLandLineNumber"] !== undefined ? data["OrganizationBasicLandLineNumber"] : <any>null;
            if (data["OrganizationBasicPepoleTBLs"] && data["OrganizationBasicPepoleTBLs"].constructor === Array) {
                this.organizationBasicPepoleTBLs = [] as any;
                for (let item of data["OrganizationBasicPepoleTBLs"])
                    this.organizationBasicPepoleTBLs!.push(PepoleTBLDTO.fromJS(item, _mappings));
            }
            if (data["OrganizationsProjects"] && data["OrganizationsProjects"].constructor === Array) {
                this.organizationsProjects = [] as any;
                for (let item of data["OrganizationsProjects"])
                    this.organizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PepoleTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<PepoleTBLDTO>(data, _mappings, PepoleTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PeopleID"] = this.peopleID !== undefined ? this.peopleID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["MobilePhone"] = this.mobilePhone !== undefined ? this.mobilePhone : <any>null;
        data["LandLineExt"] = this.landLineExt !== undefined ? this.landLineExt : <any>null;
        data["EmailAdress"] = this.emailAdress !== undefined ? this.emailAdress : <any>null;
        data["OrgID"] = this.orgID !== undefined ? this.orgID : <any>null;
        data["OrganizationBasicOrgID"] = this.organizationBasicOrgID !== undefined ? this.organizationBasicOrgID : <any>null;
        data["OrganizationBasicOrgArName"] = this.organizationBasicOrgArName !== undefined ? this.organizationBasicOrgArName : <any>null;
        data["OrganizationBasicOrgEnName"] = this.organizationBasicOrgEnName !== undefined ? this.organizationBasicOrgEnName : <any>null;
        data["OrganizationBasicLandLineNumber"] = this.organizationBasicLandLineNumber !== undefined ? this.organizationBasicLandLineNumber : <any>null;
        if (this.organizationBasicPepoleTBLs && this.organizationBasicPepoleTBLs.constructor === Array) {
            data["OrganizationBasicPepoleTBLs"] = [];
            for (let item of this.organizationBasicPepoleTBLs)
                data["OrganizationBasicPepoleTBLs"].push(item.toJSON());
        }
        if (this.organizationsProjects && this.organizationsProjects.constructor === Array) {
            data["OrganizationsProjects"] = [];
            for (let item of this.organizationsProjects)
                data["OrganizationsProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPepoleTBLDTO {
    peopleID?: number | null;
    arName: string;
    enName: string;
    mobilePhone: string;
    landLineExt: string;
    emailAdress: string;
    orgID?: number | null;
    organizationBasicOrgID?: number | null;
    organizationBasicOrgArName?: string | null;
    organizationBasicOrgEnName?: string | null;
    organizationBasicLandLineNumber?: string | null;
    organizationBasicPepoleTBLs?: PepoleTBLDTO[] | null;
    organizationsProjects?: OrganizationsProjectDTO[] | null;
}

export class DeliverableStageDTO implements IDeliverableStageDTO {
    deliverableID?: number | null;
    stageID?: number | null;
    deliverableArName!: string;
    deliverableEnName!: string;
    startDate!: Date;
    endDate!: Date;
    deliverableBudget!: number;
    stageProjectStageID?: number | null;
    stageProjectProjectID?: number | null;
    stageProjectStageArName?: string | null;
    stageProjectStageEnName?: string | null;
    stageProjectStartDate?: Date | null;
    stageProjectEndDate?: Date | null;
    stageProjectStageBudget?: number | null;
    stageProjectDeliverableStages?: DeliverableStageDTO[] | null;
    stageProjectProjectTBLProjectID?: number | null;
    stageProjectProjectTBLProjectNumber?: string | null;
    stageProjectProjectTBLArName?: string | null;
    stageProjectProjectTBLEnName?: string | null;
    stageProjectProjectTBLStartDate?: Date | null;
    stageProjectProjectTBLMainContractAmount?: number | null;
    stageProjectProjectTBLEndDate?: Date | null;
    stageProjectProjectTBLIsActiveProject?: boolean | null;
    stageProjectProjectTBLContractsChanges?: ContractsChangeDTO[] | null;
    stageProjectProjectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    stageProjectProjectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    stageProjectProjectTBLStageProjects?: StageProjectDTO[] | null;

    constructor(data?: IDeliverableStageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.deliverableID = data["DeliverableID"] !== undefined ? data["DeliverableID"] : <any>null;
            this.stageID = data["StageID"] !== undefined ? data["StageID"] : <any>null;
            this.deliverableArName = data["DeliverableArName"] !== undefined ? data["DeliverableArName"] : <any>null;
            this.deliverableEnName = data["DeliverableEnName"] !== undefined ? data["DeliverableEnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.deliverableBudget = data["DeliverableBudget"] !== undefined ? data["DeliverableBudget"] : <any>null;
            this.stageProjectStageID = data["StageProjectStageID"] !== undefined ? data["StageProjectStageID"] : <any>null;
            this.stageProjectProjectID = data["StageProjectProjectID"] !== undefined ? data["StageProjectProjectID"] : <any>null;
            this.stageProjectStageArName = data["StageProjectStageArName"] !== undefined ? data["StageProjectStageArName"] : <any>null;
            this.stageProjectStageEnName = data["StageProjectStageEnName"] !== undefined ? data["StageProjectStageEnName"] : <any>null;
            this.stageProjectStartDate = data["StageProjectStartDate"] ? new Date(data["StageProjectStartDate"].toString()) : <any>null;
            this.stageProjectEndDate = data["StageProjectEndDate"] ? new Date(data["StageProjectEndDate"].toString()) : <any>null;
            this.stageProjectStageBudget = data["StageProjectStageBudget"] !== undefined ? data["StageProjectStageBudget"] : <any>null;
            if (data["StageProjectDeliverableStages"] && data["StageProjectDeliverableStages"].constructor === Array) {
                this.stageProjectDeliverableStages = [] as any;
                for (let item of data["StageProjectDeliverableStages"])
                    this.stageProjectDeliverableStages!.push(DeliverableStageDTO.fromJS(item, _mappings));
            }
            this.stageProjectProjectTBLProjectID = data["StageProjectProjectTBLProjectID"] !== undefined ? data["StageProjectProjectTBLProjectID"] : <any>null;
            this.stageProjectProjectTBLProjectNumber = data["StageProjectProjectTBLProjectNumber"] !== undefined ? data["StageProjectProjectTBLProjectNumber"] : <any>null;
            this.stageProjectProjectTBLArName = data["StageProjectProjectTBLArName"] !== undefined ? data["StageProjectProjectTBLArName"] : <any>null;
            this.stageProjectProjectTBLEnName = data["StageProjectProjectTBLEnName"] !== undefined ? data["StageProjectProjectTBLEnName"] : <any>null;
            this.stageProjectProjectTBLStartDate = data["StageProjectProjectTBLStartDate"] ? new Date(data["StageProjectProjectTBLStartDate"].toString()) : <any>null;
            this.stageProjectProjectTBLMainContractAmount = data["StageProjectProjectTBLMainContractAmount"] !== undefined ? data["StageProjectProjectTBLMainContractAmount"] : <any>null;
            this.stageProjectProjectTBLEndDate = data["StageProjectProjectTBLEndDate"] ? new Date(data["StageProjectProjectTBLEndDate"].toString()) : <any>null;
            this.stageProjectProjectTBLIsActiveProject = data["StageProjectProjectTBLIsActiveProject"] !== undefined ? data["StageProjectProjectTBLIsActiveProject"] : <any>null;
            if (data["StageProjectProjectTBLContractsChanges"] && data["StageProjectProjectTBLContractsChanges"].constructor === Array) {
                this.stageProjectProjectTBLContractsChanges = [] as any;
                for (let item of data["StageProjectProjectTBLContractsChanges"])
                    this.stageProjectProjectTBLContractsChanges!.push(ContractsChangeDTO.fromJS(item, _mappings));
            }
            if (data["StageProjectProjectTBLOrganizationsProjects"] && data["StageProjectProjectTBLOrganizationsProjects"].constructor === Array) {
                this.stageProjectProjectTBLOrganizationsProjects = [] as any;
                for (let item of data["StageProjectProjectTBLOrganizationsProjects"])
                    this.stageProjectProjectTBLOrganizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
            if (data["StageProjectProjectTBLProjectEmployees"] && data["StageProjectProjectTBLProjectEmployees"].constructor === Array) {
                this.stageProjectProjectTBLProjectEmployees = [] as any;
                for (let item of data["StageProjectProjectTBLProjectEmployees"])
                    this.stageProjectProjectTBLProjectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
            if (data["StageProjectProjectTBLStageProjects"] && data["StageProjectProjectTBLStageProjects"].constructor === Array) {
                this.stageProjectProjectTBLStageProjects = [] as any;
                for (let item of data["StageProjectProjectTBLStageProjects"])
                    this.stageProjectProjectTBLStageProjects!.push(StageProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): DeliverableStageDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeliverableStageDTO>(data, _mappings, DeliverableStageDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DeliverableID"] = this.deliverableID !== undefined ? this.deliverableID : <any>null;
        data["StageID"] = this.stageID !== undefined ? this.stageID : <any>null;
        data["DeliverableArName"] = this.deliverableArName !== undefined ? this.deliverableArName : <any>null;
        data["DeliverableEnName"] = this.deliverableEnName !== undefined ? this.deliverableEnName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["DeliverableBudget"] = this.deliverableBudget !== undefined ? this.deliverableBudget : <any>null;
        data["StageProjectStageID"] = this.stageProjectStageID !== undefined ? this.stageProjectStageID : <any>null;
        data["StageProjectProjectID"] = this.stageProjectProjectID !== undefined ? this.stageProjectProjectID : <any>null;
        data["StageProjectStageArName"] = this.stageProjectStageArName !== undefined ? this.stageProjectStageArName : <any>null;
        data["StageProjectStageEnName"] = this.stageProjectStageEnName !== undefined ? this.stageProjectStageEnName : <any>null;
        data["StageProjectStartDate"] = this.stageProjectStartDate ? this.stageProjectStartDate.toISOString() : <any>null;
        data["StageProjectEndDate"] = this.stageProjectEndDate ? this.stageProjectEndDate.toISOString() : <any>null;
        data["StageProjectStageBudget"] = this.stageProjectStageBudget !== undefined ? this.stageProjectStageBudget : <any>null;
        if (this.stageProjectDeliverableStages && this.stageProjectDeliverableStages.constructor === Array) {
            data["StageProjectDeliverableStages"] = [];
            for (let item of this.stageProjectDeliverableStages)
                data["StageProjectDeliverableStages"].push(item.toJSON());
        }
        data["StageProjectProjectTBLProjectID"] = this.stageProjectProjectTBLProjectID !== undefined ? this.stageProjectProjectTBLProjectID : <any>null;
        data["StageProjectProjectTBLProjectNumber"] = this.stageProjectProjectTBLProjectNumber !== undefined ? this.stageProjectProjectTBLProjectNumber : <any>null;
        data["StageProjectProjectTBLArName"] = this.stageProjectProjectTBLArName !== undefined ? this.stageProjectProjectTBLArName : <any>null;
        data["StageProjectProjectTBLEnName"] = this.stageProjectProjectTBLEnName !== undefined ? this.stageProjectProjectTBLEnName : <any>null;
        data["StageProjectProjectTBLStartDate"] = this.stageProjectProjectTBLStartDate ? this.stageProjectProjectTBLStartDate.toISOString() : <any>null;
        data["StageProjectProjectTBLMainContractAmount"] = this.stageProjectProjectTBLMainContractAmount !== undefined ? this.stageProjectProjectTBLMainContractAmount : <any>null;
        data["StageProjectProjectTBLEndDate"] = this.stageProjectProjectTBLEndDate ? this.stageProjectProjectTBLEndDate.toISOString() : <any>null;
        data["StageProjectProjectTBLIsActiveProject"] = this.stageProjectProjectTBLIsActiveProject !== undefined ? this.stageProjectProjectTBLIsActiveProject : <any>null;
        if (this.stageProjectProjectTBLContractsChanges && this.stageProjectProjectTBLContractsChanges.constructor === Array) {
            data["StageProjectProjectTBLContractsChanges"] = [];
            for (let item of this.stageProjectProjectTBLContractsChanges)
                data["StageProjectProjectTBLContractsChanges"].push(item.toJSON());
        }
        if (this.stageProjectProjectTBLOrganizationsProjects && this.stageProjectProjectTBLOrganizationsProjects.constructor === Array) {
            data["StageProjectProjectTBLOrganizationsProjects"] = [];
            for (let item of this.stageProjectProjectTBLOrganizationsProjects)
                data["StageProjectProjectTBLOrganizationsProjects"].push(item.toJSON());
        }
        if (this.stageProjectProjectTBLProjectEmployees && this.stageProjectProjectTBLProjectEmployees.constructor === Array) {
            data["StageProjectProjectTBLProjectEmployees"] = [];
            for (let item of this.stageProjectProjectTBLProjectEmployees)
                data["StageProjectProjectTBLProjectEmployees"].push(item.toJSON());
        }
        if (this.stageProjectProjectTBLStageProjects && this.stageProjectProjectTBLStageProjects.constructor === Array) {
            data["StageProjectProjectTBLStageProjects"] = [];
            for (let item of this.stageProjectProjectTBLStageProjects)
                data["StageProjectProjectTBLStageProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeliverableStageDTO {
    deliverableID?: number | null;
    stageID?: number | null;
    deliverableArName: string;
    deliverableEnName: string;
    startDate: Date;
    endDate: Date;
    deliverableBudget: number;
    stageProjectStageID?: number | null;
    stageProjectProjectID?: number | null;
    stageProjectStageArName?: string | null;
    stageProjectStageEnName?: string | null;
    stageProjectStartDate?: Date | null;
    stageProjectEndDate?: Date | null;
    stageProjectStageBudget?: number | null;
    stageProjectDeliverableStages?: DeliverableStageDTO[] | null;
    stageProjectProjectTBLProjectID?: number | null;
    stageProjectProjectTBLProjectNumber?: string | null;
    stageProjectProjectTBLArName?: string | null;
    stageProjectProjectTBLEnName?: string | null;
    stageProjectProjectTBLStartDate?: Date | null;
    stageProjectProjectTBLMainContractAmount?: number | null;
    stageProjectProjectTBLEndDate?: Date | null;
    stageProjectProjectTBLIsActiveProject?: boolean | null;
    stageProjectProjectTBLContractsChanges?: ContractsChangeDTO[] | null;
    stageProjectProjectTBLOrganizationsProjects?: OrganizationsProjectDTO[] | null;
    stageProjectProjectTBLProjectEmployees?: ProjectEmployeeDTO[] | null;
    stageProjectProjectTBLStageProjects?: StageProjectDTO[] | null;
}

export class ContractsChange implements IContractsChange {
    iD?: number | null;
    projectID?: number | null;
    changedDescription?: string | null;
    originalAmount?: number | null;
    newAmount?: number | null;
    projectTBL?: ProjectTBL | null;

    constructor(data?: IContractsChange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.changedDescription = data["ChangedDescription"] !== undefined ? data["ChangedDescription"] : <any>null;
            this.originalAmount = data["OriginalAmount"] !== undefined ? data["OriginalAmount"] : <any>null;
            this.newAmount = data["NewAmount"] !== undefined ? data["NewAmount"] : <any>null;
            this.projectTBL = data["ProjectTBL"] ? ProjectTBL.fromJS(data["ProjectTBL"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ContractsChange {
        data = typeof data === 'object' ? data : {};
        return createInstance<ContractsChange>(data, _mappings, ContractsChange);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["ChangedDescription"] = this.changedDescription !== undefined ? this.changedDescription : <any>null;
        data["OriginalAmount"] = this.originalAmount !== undefined ? this.originalAmount : <any>null;
        data["NewAmount"] = this.newAmount !== undefined ? this.newAmount : <any>null;
        data["ProjectTBL"] = this.projectTBL ? this.projectTBL.toJSON() : <any>null;
        return data; 
    }
}

export interface IContractsChange {
    iD?: number | null;
    projectID?: number | null;
    changedDescription?: string | null;
    originalAmount?: number | null;
    newAmount?: number | null;
    projectTBL?: ProjectTBL | null;
}

export class ProjectTBL implements IProjectTBL {
    projectID?: number | null;
    projectNumber?: string | null;
    arName?: string | null;
    enName?: string | null;
    startDate?: Date | null;
    mainContractAmount?: number | null;
    endDate?: Date | null;
    isActiveProject?: boolean | null;
    contractsChanges?: ContractsChange[] | null;
    organizationsProjects?: OrganizationsProject[] | null;
    projectEmployees?: ProjectEmployee[] | null;
    stageProjects?: StageProject[] | null;

    constructor(data?: IProjectTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.projectNumber = data["ProjectNumber"] !== undefined ? data["ProjectNumber"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.mainContractAmount = data["MainContractAmount"] !== undefined ? data["MainContractAmount"] : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.isActiveProject = data["IsActiveProject"] !== undefined ? data["IsActiveProject"] : <any>null;
            if (data["ContractsChanges"] && data["ContractsChanges"].constructor === Array) {
                this.contractsChanges = [] as any;
                for (let item of data["ContractsChanges"])
                    this.contractsChanges!.push(ContractsChange.fromJS(item, _mappings));
            }
            if (data["OrganizationsProjects"] && data["OrganizationsProjects"].constructor === Array) {
                this.organizationsProjects = [] as any;
                for (let item of data["OrganizationsProjects"])
                    this.organizationsProjects!.push(OrganizationsProject.fromJS(item, _mappings));
            }
            if (data["ProjectEmployees"] && data["ProjectEmployees"].constructor === Array) {
                this.projectEmployees = [] as any;
                for (let item of data["ProjectEmployees"])
                    this.projectEmployees!.push(ProjectEmployee.fromJS(item, _mappings));
            }
            if (data["StageProjects"] && data["StageProjects"].constructor === Array) {
                this.stageProjects = [] as any;
                for (let item of data["StageProjects"])
                    this.stageProjects!.push(StageProject.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ProjectTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProjectTBL>(data, _mappings, ProjectTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["ProjectNumber"] = this.projectNumber !== undefined ? this.projectNumber : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["MainContractAmount"] = this.mainContractAmount !== undefined ? this.mainContractAmount : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["IsActiveProject"] = this.isActiveProject !== undefined ? this.isActiveProject : <any>null;
        if (this.contractsChanges && this.contractsChanges.constructor === Array) {
            data["ContractsChanges"] = [];
            for (let item of this.contractsChanges)
                data["ContractsChanges"].push(item.toJSON());
        }
        if (this.organizationsProjects && this.organizationsProjects.constructor === Array) {
            data["OrganizationsProjects"] = [];
            for (let item of this.organizationsProjects)
                data["OrganizationsProjects"].push(item.toJSON());
        }
        if (this.projectEmployees && this.projectEmployees.constructor === Array) {
            data["ProjectEmployees"] = [];
            for (let item of this.projectEmployees)
                data["ProjectEmployees"].push(item.toJSON());
        }
        if (this.stageProjects && this.stageProjects.constructor === Array) {
            data["StageProjects"] = [];
            for (let item of this.stageProjects)
                data["StageProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectTBL {
    projectID?: number | null;
    projectNumber?: string | null;
    arName?: string | null;
    enName?: string | null;
    startDate?: Date | null;
    mainContractAmount?: number | null;
    endDate?: Date | null;
    isActiveProject?: boolean | null;
    contractsChanges?: ContractsChange[] | null;
    organizationsProjects?: OrganizationsProject[] | null;
    projectEmployees?: ProjectEmployee[] | null;
    stageProjects?: StageProject[] | null;
}

export class OrganizationsProject implements IOrganizationsProject {
    serNum?: number | null;
    peopleID?: number | null;
    projectID?: number | null;
    orgTypeID?: number | null;
    oegType?: OegType | null;
    pepoleTBL?: PepoleTBL | null;
    projectTBL?: ProjectTBL | null;

    constructor(data?: IOrganizationsProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.serNum = data["SerNum"] !== undefined ? data["SerNum"] : <any>null;
            this.peopleID = data["PeopleID"] !== undefined ? data["PeopleID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.orgTypeID = data["OrgTypeID"] !== undefined ? data["OrgTypeID"] : <any>null;
            this.oegType = data["OegType"] ? OegType.fromJS(data["OegType"], _mappings) : <any>null;
            this.pepoleTBL = data["PepoleTBL"] ? PepoleTBL.fromJS(data["PepoleTBL"], _mappings) : <any>null;
            this.projectTBL = data["ProjectTBL"] ? ProjectTBL.fromJS(data["ProjectTBL"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): OrganizationsProject {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrganizationsProject>(data, _mappings, OrganizationsProject);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SerNum"] = this.serNum !== undefined ? this.serNum : <any>null;
        data["PeopleID"] = this.peopleID !== undefined ? this.peopleID : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["OrgTypeID"] = this.orgTypeID !== undefined ? this.orgTypeID : <any>null;
        data["OegType"] = this.oegType ? this.oegType.toJSON() : <any>null;
        data["PepoleTBL"] = this.pepoleTBL ? this.pepoleTBL.toJSON() : <any>null;
        data["ProjectTBL"] = this.projectTBL ? this.projectTBL.toJSON() : <any>null;
        return data; 
    }
}

export interface IOrganizationsProject {
    serNum?: number | null;
    peopleID?: number | null;
    projectID?: number | null;
    orgTypeID?: number | null;
    oegType?: OegType | null;
    pepoleTBL?: PepoleTBL | null;
    projectTBL?: ProjectTBL | null;
}

export class ProjectEmployee implements IProjectEmployee {
    iD?: number | null;
    projectID?: number | null;
    empID?: number | null;
    startFrom?: Date | null;
    endTo?: Date | null;
    positionInProject?: number | null;
    positionInProject1?: PositionInProject | null;
    projectTBL?: ProjectTBL | null;

    constructor(data?: IProjectEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.startFrom = data["StartFrom"] ? new Date(data["StartFrom"].toString()) : <any>null;
            this.endTo = data["EndTo"] ? new Date(data["EndTo"].toString()) : <any>null;
            this.positionInProject = data["PositionInProject"] !== undefined ? data["PositionInProject"] : <any>null;
            this.positionInProject1 = data["PositionInProject1"] ? PositionInProject.fromJS(data["PositionInProject1"], _mappings) : <any>null;
            this.projectTBL = data["ProjectTBL"] ? ProjectTBL.fromJS(data["ProjectTBL"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ProjectEmployee {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProjectEmployee>(data, _mappings, ProjectEmployee);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["StartFrom"] = this.startFrom ? this.startFrom.toISOString() : <any>null;
        data["EndTo"] = this.endTo ? this.endTo.toISOString() : <any>null;
        data["PositionInProject"] = this.positionInProject !== undefined ? this.positionInProject : <any>null;
        data["PositionInProject1"] = this.positionInProject1 ? this.positionInProject1.toJSON() : <any>null;
        data["ProjectTBL"] = this.projectTBL ? this.projectTBL.toJSON() : <any>null;
        return data; 
    }
}

export interface IProjectEmployee {
    iD?: number | null;
    projectID?: number | null;
    empID?: number | null;
    startFrom?: Date | null;
    endTo?: Date | null;
    positionInProject?: number | null;
    positionInProject1?: PositionInProject | null;
    projectTBL?: ProjectTBL | null;
}

export class StageProject implements IStageProject {
    stageID?: number | null;
    projectID?: number | null;
    stageArName?: string | null;
    stageEnName?: string | null;
    startDate?: Date | null;
    endDate?: Date | null;
    stageBudget?: number | null;
    deliverableStages?: DeliverableStage[] | null;
    projectTBL?: ProjectTBL | null;

    constructor(data?: IStageProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.stageID = data["StageID"] !== undefined ? data["StageID"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.stageArName = data["StageArName"] !== undefined ? data["StageArName"] : <any>null;
            this.stageEnName = data["StageEnName"] !== undefined ? data["StageEnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.stageBudget = data["StageBudget"] !== undefined ? data["StageBudget"] : <any>null;
            if (data["DeliverableStages"] && data["DeliverableStages"].constructor === Array) {
                this.deliverableStages = [] as any;
                for (let item of data["DeliverableStages"])
                    this.deliverableStages!.push(DeliverableStage.fromJS(item, _mappings));
            }
            this.projectTBL = data["ProjectTBL"] ? ProjectTBL.fromJS(data["ProjectTBL"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): StageProject {
        data = typeof data === 'object' ? data : {};
        return createInstance<StageProject>(data, _mappings, StageProject);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StageID"] = this.stageID !== undefined ? this.stageID : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["StageArName"] = this.stageArName !== undefined ? this.stageArName : <any>null;
        data["StageEnName"] = this.stageEnName !== undefined ? this.stageEnName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["StageBudget"] = this.stageBudget !== undefined ? this.stageBudget : <any>null;
        if (this.deliverableStages && this.deliverableStages.constructor === Array) {
            data["DeliverableStages"] = [];
            for (let item of this.deliverableStages)
                data["DeliverableStages"].push(item.toJSON());
        }
        data["ProjectTBL"] = this.projectTBL ? this.projectTBL.toJSON() : <any>null;
        return data; 
    }
}

export interface IStageProject {
    stageID?: number | null;
    projectID?: number | null;
    stageArName?: string | null;
    stageEnName?: string | null;
    startDate?: Date | null;
    endDate?: Date | null;
    stageBudget?: number | null;
    deliverableStages?: DeliverableStage[] | null;
    projectTBL?: ProjectTBL | null;
}

export class OegType implements IOegType {
    orgTypeID?: number | null;
    typeArName?: string | null;
    typeEnName?: string | null;
    organizationsProjects?: OrganizationsProject[] | null;

    constructor(data?: IOegType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.orgTypeID = data["OrgTypeID"] !== undefined ? data["OrgTypeID"] : <any>null;
            this.typeArName = data["TypeArName"] !== undefined ? data["TypeArName"] : <any>null;
            this.typeEnName = data["TypeEnName"] !== undefined ? data["TypeEnName"] : <any>null;
            if (data["OrganizationsProjects"] && data["OrganizationsProjects"].constructor === Array) {
                this.organizationsProjects = [] as any;
                for (let item of data["OrganizationsProjects"])
                    this.organizationsProjects!.push(OrganizationsProject.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OegType {
        data = typeof data === 'object' ? data : {};
        return createInstance<OegType>(data, _mappings, OegType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrgTypeID"] = this.orgTypeID !== undefined ? this.orgTypeID : <any>null;
        data["TypeArName"] = this.typeArName !== undefined ? this.typeArName : <any>null;
        data["TypeEnName"] = this.typeEnName !== undefined ? this.typeEnName : <any>null;
        if (this.organizationsProjects && this.organizationsProjects.constructor === Array) {
            data["OrganizationsProjects"] = [];
            for (let item of this.organizationsProjects)
                data["OrganizationsProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOegType {
    orgTypeID?: number | null;
    typeArName?: string | null;
    typeEnName?: string | null;
    organizationsProjects?: OrganizationsProject[] | null;
}

export class PepoleTBL implements IPepoleTBL {
    peopleID?: number | null;
    arName?: string | null;
    enName?: string | null;
    mobilePhone?: string | null;
    landLineExt?: string | null;
    emailAdress?: string | null;
    orgID?: number | null;
    organizationBasic?: OrganizationBasic | null;
    organizationsProjects?: OrganizationsProject[] | null;

    constructor(data?: IPepoleTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.peopleID = data["PeopleID"] !== undefined ? data["PeopleID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.mobilePhone = data["MobilePhone"] !== undefined ? data["MobilePhone"] : <any>null;
            this.landLineExt = data["LandLineExt"] !== undefined ? data["LandLineExt"] : <any>null;
            this.emailAdress = data["EmailAdress"] !== undefined ? data["EmailAdress"] : <any>null;
            this.orgID = data["OrgID"] !== undefined ? data["OrgID"] : <any>null;
            this.organizationBasic = data["OrganizationBasic"] ? OrganizationBasic.fromJS(data["OrganizationBasic"], _mappings) : <any>null;
            if (data["OrganizationsProjects"] && data["OrganizationsProjects"].constructor === Array) {
                this.organizationsProjects = [] as any;
                for (let item of data["OrganizationsProjects"])
                    this.organizationsProjects!.push(OrganizationsProject.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PepoleTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<PepoleTBL>(data, _mappings, PepoleTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PeopleID"] = this.peopleID !== undefined ? this.peopleID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["MobilePhone"] = this.mobilePhone !== undefined ? this.mobilePhone : <any>null;
        data["LandLineExt"] = this.landLineExt !== undefined ? this.landLineExt : <any>null;
        data["EmailAdress"] = this.emailAdress !== undefined ? this.emailAdress : <any>null;
        data["OrgID"] = this.orgID !== undefined ? this.orgID : <any>null;
        data["OrganizationBasic"] = this.organizationBasic ? this.organizationBasic.toJSON() : <any>null;
        if (this.organizationsProjects && this.organizationsProjects.constructor === Array) {
            data["OrganizationsProjects"] = [];
            for (let item of this.organizationsProjects)
                data["OrganizationsProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPepoleTBL {
    peopleID?: number | null;
    arName?: string | null;
    enName?: string | null;
    mobilePhone?: string | null;
    landLineExt?: string | null;
    emailAdress?: string | null;
    orgID?: number | null;
    organizationBasic?: OrganizationBasic | null;
    organizationsProjects?: OrganizationsProject[] | null;
}

export class PositionInProject implements IPositionInProject {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    projectEmployees?: ProjectEmployee[] | null;

    constructor(data?: IPositionInProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["ProjectEmployees"] && data["ProjectEmployees"].constructor === Array) {
                this.projectEmployees = [] as any;
                for (let item of data["ProjectEmployees"])
                    this.projectEmployees!.push(ProjectEmployee.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PositionInProject {
        data = typeof data === 'object' ? data : {};
        return createInstance<PositionInProject>(data, _mappings, PositionInProject);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.projectEmployees && this.projectEmployees.constructor === Array) {
            data["ProjectEmployees"] = [];
            for (let item of this.projectEmployees)
                data["ProjectEmployees"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPositionInProject {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
    projectEmployees?: ProjectEmployee[] | null;
}

export class DeliverableStage implements IDeliverableStage {
    deliverableID?: number | null;
    stageID?: number | null;
    deliverableArName?: string | null;
    deliverableEnName?: string | null;
    startDate?: Date | null;
    endDate?: Date | null;
    deliverableBudget?: number | null;
    stageProject?: StageProject | null;

    constructor(data?: IDeliverableStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.deliverableID = data["DeliverableID"] !== undefined ? data["DeliverableID"] : <any>null;
            this.stageID = data["StageID"] !== undefined ? data["StageID"] : <any>null;
            this.deliverableArName = data["DeliverableArName"] !== undefined ? data["DeliverableArName"] : <any>null;
            this.deliverableEnName = data["DeliverableEnName"] !== undefined ? data["DeliverableEnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.deliverableBudget = data["DeliverableBudget"] !== undefined ? data["DeliverableBudget"] : <any>null;
            this.stageProject = data["StageProject"] ? StageProject.fromJS(data["StageProject"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): DeliverableStage {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeliverableStage>(data, _mappings, DeliverableStage);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DeliverableID"] = this.deliverableID !== undefined ? this.deliverableID : <any>null;
        data["StageID"] = this.stageID !== undefined ? this.stageID : <any>null;
        data["DeliverableArName"] = this.deliverableArName !== undefined ? this.deliverableArName : <any>null;
        data["DeliverableEnName"] = this.deliverableEnName !== undefined ? this.deliverableEnName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["DeliverableBudget"] = this.deliverableBudget !== undefined ? this.deliverableBudget : <any>null;
        data["StageProject"] = this.stageProject ? this.stageProject.toJSON() : <any>null;
        return data; 
    }
}

export interface IDeliverableStage {
    deliverableID?: number | null;
    stageID?: number | null;
    deliverableArName?: string | null;
    deliverableEnName?: string | null;
    startDate?: Date | null;
    endDate?: Date | null;
    deliverableBudget?: number | null;
    stageProject?: StageProject | null;
}

export class OrganizationBasic implements IOrganizationBasic {
    orgID?: number | null;
    orgArName?: string | null;
    orgEnName?: string | null;
    landLineNumber?: string | null;
    pepoleTBLs?: PepoleTBL[] | null;

    constructor(data?: IOrganizationBasic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.orgID = data["OrgID"] !== undefined ? data["OrgID"] : <any>null;
            this.orgArName = data["OrgArName"] !== undefined ? data["OrgArName"] : <any>null;
            this.orgEnName = data["OrgEnName"] !== undefined ? data["OrgEnName"] : <any>null;
            this.landLineNumber = data["LandLineNumber"] !== undefined ? data["LandLineNumber"] : <any>null;
            if (data["PepoleTBLs"] && data["PepoleTBLs"].constructor === Array) {
                this.pepoleTBLs = [] as any;
                for (let item of data["PepoleTBLs"])
                    this.pepoleTBLs!.push(PepoleTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OrganizationBasic {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrganizationBasic>(data, _mappings, OrganizationBasic);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrgID"] = this.orgID !== undefined ? this.orgID : <any>null;
        data["OrgArName"] = this.orgArName !== undefined ? this.orgArName : <any>null;
        data["OrgEnName"] = this.orgEnName !== undefined ? this.orgEnName : <any>null;
        data["LandLineNumber"] = this.landLineNumber !== undefined ? this.landLineNumber : <any>null;
        if (this.pepoleTBLs && this.pepoleTBLs.constructor === Array) {
            data["PepoleTBLs"] = [];
            for (let item of this.pepoleTBLs)
                data["PepoleTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationBasic {
    orgID?: number | null;
    orgArName?: string | null;
    orgEnName?: string | null;
    landLineNumber?: string | null;
    pepoleTBLs?: PepoleTBL[] | null;
}

export class DivisionTBLDTO implements IDivisionTBLDTO {
    divisionID?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: IDivisionTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.divisionID = data["DivisionID"] !== undefined ? data["DivisionID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): DivisionTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DivisionTBLDTO>(data, _mappings, DivisionTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DivisionID"] = this.divisionID !== undefined ? this.divisionID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IDivisionTBLDTO {
    divisionID?: number | null;
    arName: string;
    enName: string;
}

export class DivisionTBL implements IDivisionTBL {
    divisionID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;

    constructor(data?: IDivisionTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.divisionID = data["DivisionID"] !== undefined ? data["DivisionID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["EmployeeTBLs"] && data["EmployeeTBLs"].constructor === Array) {
                this.employeeTBLs = [] as any;
                for (let item of data["EmployeeTBLs"])
                    this.employeeTBLs!.push(EmployeeTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): DivisionTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<DivisionTBL>(data, _mappings, DivisionTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DivisionID"] = this.divisionID !== undefined ? this.divisionID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.employeeTBLs && this.employeeTBLs.constructor === Array) {
            data["EmployeeTBLs"] = [];
            for (let item of this.employeeTBLs)
                data["EmployeeTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDivisionTBL {
    divisionID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;
}

export class EmployeeTBL implements IEmployeeTBL {
    employeeID?: number | null;
    arName?: string | null;
    enName?: string | null;
    startDate?: Date | null;
    bithDate?: Date | null;
    nationalityID?: number | null;
    divisionID?: number | null;
    jobTitleID?: number | null;
    phoneNumber?: string | null;
    isActiveStatus?: boolean | null;
    emailAddress?: string | null;
    offDate?: Date | null;
    offTypeID?: number | null;
    divisionTBL?: DivisionTBL | null;
    employeeOffType?: EmployeeOffType | null;
    jobTitleTBL?: JobTitleTBL | null;
    nationalityTBL?: NationalityTBL | null;

    constructor(data?: IEmployeeTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.employeeID = data["EmployeeID"] !== undefined ? data["EmployeeID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.bithDate = data["BithDate"] ? new Date(data["BithDate"].toString()) : <any>null;
            this.nationalityID = data["NationalityID"] !== undefined ? data["NationalityID"] : <any>null;
            this.divisionID = data["DivisionID"] !== undefined ? data["DivisionID"] : <any>null;
            this.jobTitleID = data["JobTitleID"] !== undefined ? data["JobTitleID"] : <any>null;
            this.phoneNumber = data["PhoneNumber"] !== undefined ? data["PhoneNumber"] : <any>null;
            this.isActiveStatus = data["IsActiveStatus"] !== undefined ? data["IsActiveStatus"] : <any>null;
            this.emailAddress = data["EmailAddress"] !== undefined ? data["EmailAddress"] : <any>null;
            this.offDate = data["OffDate"] ? new Date(data["OffDate"].toString()) : <any>null;
            this.offTypeID = data["OffTypeID"] !== undefined ? data["OffTypeID"] : <any>null;
            this.divisionTBL = data["DivisionTBL"] ? DivisionTBL.fromJS(data["DivisionTBL"], _mappings) : <any>null;
            this.employeeOffType = data["EmployeeOffType"] ? EmployeeOffType.fromJS(data["EmployeeOffType"], _mappings) : <any>null;
            this.jobTitleTBL = data["JobTitleTBL"] ? JobTitleTBL.fromJS(data["JobTitleTBL"], _mappings) : <any>null;
            this.nationalityTBL = data["NationalityTBL"] ? NationalityTBL.fromJS(data["NationalityTBL"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EmployeeTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployeeTBL>(data, _mappings, EmployeeTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EmployeeID"] = this.employeeID !== undefined ? this.employeeID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["BithDate"] = this.bithDate ? this.bithDate.toISOString() : <any>null;
        data["NationalityID"] = this.nationalityID !== undefined ? this.nationalityID : <any>null;
        data["DivisionID"] = this.divisionID !== undefined ? this.divisionID : <any>null;
        data["JobTitleID"] = this.jobTitleID !== undefined ? this.jobTitleID : <any>null;
        data["PhoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["IsActiveStatus"] = this.isActiveStatus !== undefined ? this.isActiveStatus : <any>null;
        data["EmailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["OffDate"] = this.offDate ? this.offDate.toISOString() : <any>null;
        data["OffTypeID"] = this.offTypeID !== undefined ? this.offTypeID : <any>null;
        data["DivisionTBL"] = this.divisionTBL ? this.divisionTBL.toJSON() : <any>null;
        data["EmployeeOffType"] = this.employeeOffType ? this.employeeOffType.toJSON() : <any>null;
        data["JobTitleTBL"] = this.jobTitleTBL ? this.jobTitleTBL.toJSON() : <any>null;
        data["NationalityTBL"] = this.nationalityTBL ? this.nationalityTBL.toJSON() : <any>null;
        return data; 
    }
}

export interface IEmployeeTBL {
    employeeID?: number | null;
    arName?: string | null;
    enName?: string | null;
    startDate?: Date | null;
    bithDate?: Date | null;
    nationalityID?: number | null;
    divisionID?: number | null;
    jobTitleID?: number | null;
    phoneNumber?: string | null;
    isActiveStatus?: boolean | null;
    emailAddress?: string | null;
    offDate?: Date | null;
    offTypeID?: number | null;
    divisionTBL?: DivisionTBL | null;
    employeeOffType?: EmployeeOffType | null;
    jobTitleTBL?: JobTitleTBL | null;
    nationalityTBL?: NationalityTBL | null;
}

export class EmployeeOffType implements IEmployeeOffType {
    employeeOffTypeID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;

    constructor(data?: IEmployeeOffType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.employeeOffTypeID = data["EmployeeOffTypeID"] !== undefined ? data["EmployeeOffTypeID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["EmployeeTBLs"] && data["EmployeeTBLs"].constructor === Array) {
                this.employeeTBLs = [] as any;
                for (let item of data["EmployeeTBLs"])
                    this.employeeTBLs!.push(EmployeeTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): EmployeeOffType {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployeeOffType>(data, _mappings, EmployeeOffType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EmployeeOffTypeID"] = this.employeeOffTypeID !== undefined ? this.employeeOffTypeID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.employeeTBLs && this.employeeTBLs.constructor === Array) {
            data["EmployeeTBLs"] = [];
            for (let item of this.employeeTBLs)
                data["EmployeeTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmployeeOffType {
    employeeOffTypeID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;
}

export class JobTitleTBL implements IJobTitleTBL {
    jobTitleID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;

    constructor(data?: IJobTitleTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.jobTitleID = data["JobTitleID"] !== undefined ? data["JobTitleID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["EmployeeTBLs"] && data["EmployeeTBLs"].constructor === Array) {
                this.employeeTBLs = [] as any;
                for (let item of data["EmployeeTBLs"])
                    this.employeeTBLs!.push(EmployeeTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): JobTitleTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<JobTitleTBL>(data, _mappings, JobTitleTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["JobTitleID"] = this.jobTitleID !== undefined ? this.jobTitleID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.employeeTBLs && this.employeeTBLs.constructor === Array) {
            data["EmployeeTBLs"] = [];
            for (let item of this.employeeTBLs)
                data["EmployeeTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IJobTitleTBL {
    jobTitleID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;
}

export class NationalityTBL implements INationalityTBL {
    nationalityID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;

    constructor(data?: INationalityTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.nationalityID = data["NationalityID"] !== undefined ? data["NationalityID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["EmployeeTBLs"] && data["EmployeeTBLs"].constructor === Array) {
                this.employeeTBLs = [] as any;
                for (let item of data["EmployeeTBLs"])
                    this.employeeTBLs!.push(EmployeeTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): NationalityTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<NationalityTBL>(data, _mappings, NationalityTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NationalityID"] = this.nationalityID !== undefined ? this.nationalityID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.employeeTBLs && this.employeeTBLs.constructor === Array) {
            data["EmployeeTBLs"] = [];
            for (let item of this.employeeTBLs)
                data["EmployeeTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INationalityTBL {
    nationalityID?: number | null;
    arName?: string | null;
    enName?: string | null;
    employeeTBLs?: EmployeeTBL[] | null;
}

export class DocumentTypeDTO implements IDocumentTypeDTO {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;

    constructor(data?: IDocumentTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentTypeDTO>(data, _mappings, DocumentTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IDocumentTypeDTO {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
}

export class EmployeeOffTypeDTO implements IEmployeeOffTypeDTO {
    employeeOffTypeID?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: IEmployeeOffTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.employeeOffTypeID = data["EmployeeOffTypeID"] !== undefined ? data["EmployeeOffTypeID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EmployeeOffTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployeeOffTypeDTO>(data, _mappings, EmployeeOffTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EmployeeOffTypeID"] = this.employeeOffTypeID !== undefined ? this.employeeOffTypeID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IEmployeeOffTypeDTO {
    employeeOffTypeID?: number | null;
    arName: string;
    enName: string;
}

export class EmployeeTaskDTO implements IEmployeeTaskDTO {
    iD?: number | null;
    taskID!: number;
    empID!: number;
    roleInTask!: number;

    constructor(data?: IEmployeeTaskDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.taskID = data["TaskID"] !== undefined ? data["TaskID"] : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.roleInTask = data["RoleInTask"] !== undefined ? data["RoleInTask"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EmployeeTaskDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployeeTaskDTO>(data, _mappings, EmployeeTaskDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["TaskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["RoleInTask"] = this.roleInTask !== undefined ? this.roleInTask : <any>null;
        return data; 
    }
}

export interface IEmployeeTaskDTO {
    iD?: number | null;
    taskID: number;
    empID: number;
    roleInTask: number;
}

export class EmployeeTBLDTO implements IEmployeeTBLDTO {
    employeeID?: number | null;
    arName!: string;
    enName!: string;
    startDate!: Date;
    bithDate!: Date;
    nationalityID!: number;
    divisionID!: number;
    jobTitleID!: number;
    phoneNumber!: string;
    isActiveStatus!: boolean;
    emailAddress!: string;
    offDate!: Date;
    offTypeID!: number;

    constructor(data?: IEmployeeTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.employeeID = data["EmployeeID"] !== undefined ? data["EmployeeID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.bithDate = data["BithDate"] ? new Date(data["BithDate"].toString()) : <any>null;
            this.nationalityID = data["NationalityID"] !== undefined ? data["NationalityID"] : <any>null;
            this.divisionID = data["DivisionID"] !== undefined ? data["DivisionID"] : <any>null;
            this.jobTitleID = data["JobTitleID"] !== undefined ? data["JobTitleID"] : <any>null;
            this.phoneNumber = data["PhoneNumber"] !== undefined ? data["PhoneNumber"] : <any>null;
            this.isActiveStatus = data["IsActiveStatus"] !== undefined ? data["IsActiveStatus"] : <any>null;
            this.emailAddress = data["EmailAddress"] !== undefined ? data["EmailAddress"] : <any>null;
            this.offDate = data["OffDate"] ? new Date(data["OffDate"].toString()) : <any>null;
            this.offTypeID = data["OffTypeID"] !== undefined ? data["OffTypeID"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EmployeeTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployeeTBLDTO>(data, _mappings, EmployeeTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EmployeeID"] = this.employeeID !== undefined ? this.employeeID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["BithDate"] = this.bithDate ? this.bithDate.toISOString() : <any>null;
        data["NationalityID"] = this.nationalityID !== undefined ? this.nationalityID : <any>null;
        data["DivisionID"] = this.divisionID !== undefined ? this.divisionID : <any>null;
        data["JobTitleID"] = this.jobTitleID !== undefined ? this.jobTitleID : <any>null;
        data["PhoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["IsActiveStatus"] = this.isActiveStatus !== undefined ? this.isActiveStatus : <any>null;
        data["EmailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["OffDate"] = this.offDate ? this.offDate.toISOString() : <any>null;
        data["OffTypeID"] = this.offTypeID !== undefined ? this.offTypeID : <any>null;
        return data; 
    }
}

export interface IEmployeeTBLDTO {
    employeeID?: number | null;
    arName: string;
    enName: string;
    startDate: Date;
    bithDate: Date;
    nationalityID: number;
    divisionID: number;
    jobTitleID: number;
    phoneNumber: string;
    isActiveStatus: boolean;
    emailAddress: string;
    offDate: Date;
    offTypeID: number;
}

export class EventTypeDTO implements IEventTypeDTO {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;

    constructor(data?: IEventTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EventTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<EventTypeDTO>(data, _mappings, EventTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IEventTypeDTO {
    iD?: number | null;
    arName?: string | null;
    enName?: string | null;
}

export class FollowUpDocumentsCircleDTO implements IFollowUpDocumentsCircleDTO {
    archiveID?: number | null;
    eventDatetime?: Date | null;
    empID?: number | null;
    eventType?: number | null;

    constructor(data?: IFollowUpDocumentsCircleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.archiveID = data["ArchiveID"] !== undefined ? data["ArchiveID"] : <any>null;
            this.eventDatetime = data["EventDatetime"] ? new Date(data["EventDatetime"].toString()) : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.eventType = data["EventType"] !== undefined ? data["EventType"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FollowUpDocumentsCircleDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<FollowUpDocumentsCircleDTO>(data, _mappings, FollowUpDocumentsCircleDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArchiveID"] = this.archiveID !== undefined ? this.archiveID : <any>null;
        data["EventDatetime"] = this.eventDatetime ? this.eventDatetime.toISOString() : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["EventType"] = this.eventType !== undefined ? this.eventType : <any>null;
        return data; 
    }
}

export interface IFollowUpDocumentsCircleDTO {
    archiveID?: number | null;
    eventDatetime?: Date | null;
    empID?: number | null;
    eventType?: number | null;
}

export class InvoicesTBL implements IInvoicesTBL {
    recordID?: number | null;
    invoicelID?: string | null;
    arName?: string | null;
    enName?: string | null;
    invoiceIssueDate?: Date | null;
    invoiceType?: number | null;
    deliveryStatus?: boolean | null;
    deliveryDate?: Date | null;
    invoiceAmount?: number | null;
    paidStatus?: boolean | null;
    paidAmount?: number | null;
    copyLink?: string | null;
    projectID?: number | null;
    empID?: number | null;
    invoiceType1?: InvoiceType | null;

    constructor(data?: IInvoicesTBL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.recordID = data["RecordID"] !== undefined ? data["RecordID"] : <any>null;
            this.invoicelID = data["InvoicelID"] !== undefined ? data["InvoicelID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.invoiceIssueDate = data["InvoiceIssueDate"] ? new Date(data["InvoiceIssueDate"].toString()) : <any>null;
            this.invoiceType = data["InvoiceType"] !== undefined ? data["InvoiceType"] : <any>null;
            this.deliveryStatus = data["DeliveryStatus"] !== undefined ? data["DeliveryStatus"] : <any>null;
            this.deliveryDate = data["DeliveryDate"] ? new Date(data["DeliveryDate"].toString()) : <any>null;
            this.invoiceAmount = data["InvoiceAmount"] !== undefined ? data["InvoiceAmount"] : <any>null;
            this.paidStatus = data["PaidStatus"] !== undefined ? data["PaidStatus"] : <any>null;
            this.paidAmount = data["PaidAmount"] !== undefined ? data["PaidAmount"] : <any>null;
            this.copyLink = data["CopyLink"] !== undefined ? data["CopyLink"] : <any>null;
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.empID = data["EmpID"] !== undefined ? data["EmpID"] : <any>null;
            this.invoiceType1 = data["InvoiceType1"] ? InvoiceType.fromJS(data["InvoiceType1"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): InvoicesTBL {
        data = typeof data === 'object' ? data : {};
        return createInstance<InvoicesTBL>(data, _mappings, InvoicesTBL);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RecordID"] = this.recordID !== undefined ? this.recordID : <any>null;
        data["InvoicelID"] = this.invoicelID !== undefined ? this.invoicelID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["InvoiceIssueDate"] = this.invoiceIssueDate ? this.invoiceIssueDate.toISOString() : <any>null;
        data["InvoiceType"] = this.invoiceType !== undefined ? this.invoiceType : <any>null;
        data["DeliveryStatus"] = this.deliveryStatus !== undefined ? this.deliveryStatus : <any>null;
        data["DeliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>null;
        data["InvoiceAmount"] = this.invoiceAmount !== undefined ? this.invoiceAmount : <any>null;
        data["PaidStatus"] = this.paidStatus !== undefined ? this.paidStatus : <any>null;
        data["PaidAmount"] = this.paidAmount !== undefined ? this.paidAmount : <any>null;
        data["CopyLink"] = this.copyLink !== undefined ? this.copyLink : <any>null;
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["EmpID"] = this.empID !== undefined ? this.empID : <any>null;
        data["InvoiceType1"] = this.invoiceType1 ? this.invoiceType1.toJSON() : <any>null;
        return data; 
    }
}

export interface IInvoicesTBL {
    recordID?: number | null;
    invoicelID?: string | null;
    arName?: string | null;
    enName?: string | null;
    invoiceIssueDate?: Date | null;
    invoiceType?: number | null;
    deliveryStatus?: boolean | null;
    deliveryDate?: Date | null;
    invoiceAmount?: number | null;
    paidStatus?: boolean | null;
    paidAmount?: number | null;
    copyLink?: string | null;
    projectID?: number | null;
    empID?: number | null;
    invoiceType1?: InvoiceType | null;
}

export class InvoiceType implements IInvoiceType {
    typeID?: number | null;
    arName?: string | null;
    enName?: string | null;
    invoicesTBLs?: InvoicesTBL[] | null;

    constructor(data?: IInvoiceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.typeID = data["TypeID"] !== undefined ? data["TypeID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["InvoicesTBLs"] && data["InvoicesTBLs"].constructor === Array) {
                this.invoicesTBLs = [] as any;
                for (let item of data["InvoicesTBLs"])
                    this.invoicesTBLs!.push(InvoicesTBL.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): InvoiceType {
        data = typeof data === 'object' ? data : {};
        return createInstance<InvoiceType>(data, _mappings, InvoiceType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TypeID"] = this.typeID !== undefined ? this.typeID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.invoicesTBLs && this.invoicesTBLs.constructor === Array) {
            data["InvoicesTBLs"] = [];
            for (let item of this.invoicesTBLs)
                data["InvoicesTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoiceType {
    typeID?: number | null;
    arName?: string | null;
    enName?: string | null;
    invoicesTBLs?: InvoicesTBL[] | null;
}

export class JobTitleTBLDTO implements IJobTitleTBLDTO {
    jobTitleID?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: IJobTitleTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.jobTitleID = data["JobTitleID"] !== undefined ? data["JobTitleID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): JobTitleTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<JobTitleTBLDTO>(data, _mappings, JobTitleTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["JobTitleID"] = this.jobTitleID !== undefined ? this.jobTitleID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IJobTitleTBLDTO {
    jobTitleID?: number | null;
    arName: string;
    enName: string;
}

export class NationalityTBLDTO implements INationalityTBLDTO {
    nationalityID?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: INationalityTBLDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.nationalityID = data["NationalityID"] !== undefined ? data["NationalityID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): NationalityTBLDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<NationalityTBLDTO>(data, _mappings, NationalityTBLDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NationalityID"] = this.nationalityID !== undefined ? this.nationalityID : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface INationalityTBLDTO {
    nationalityID?: number | null;
    arName: string;
    enName: string;
}

export class OegTypeDTO implements IOegTypeDTO {
    orgTypeID?: number | null;
    typeArName!: string;
    typeEnName!: string;
    organizationsProjects?: OrganizationsProjectDTO[] | null;

    constructor(data?: IOegTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.orgTypeID = data["OrgTypeID"] !== undefined ? data["OrgTypeID"] : <any>null;
            this.typeArName = data["TypeArName"] !== undefined ? data["TypeArName"] : <any>null;
            this.typeEnName = data["TypeEnName"] !== undefined ? data["TypeEnName"] : <any>null;
            if (data["OrganizationsProjects"] && data["OrganizationsProjects"].constructor === Array) {
                this.organizationsProjects = [] as any;
                for (let item of data["OrganizationsProjects"])
                    this.organizationsProjects!.push(OrganizationsProjectDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OegTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<OegTypeDTO>(data, _mappings, OegTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrgTypeID"] = this.orgTypeID !== undefined ? this.orgTypeID : <any>null;
        data["TypeArName"] = this.typeArName !== undefined ? this.typeArName : <any>null;
        data["TypeEnName"] = this.typeEnName !== undefined ? this.typeEnName : <any>null;
        if (this.organizationsProjects && this.organizationsProjects.constructor === Array) {
            data["OrganizationsProjects"] = [];
            for (let item of this.organizationsProjects)
                data["OrganizationsProjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOegTypeDTO {
    orgTypeID?: number | null;
    typeArName: string;
    typeEnName: string;
    organizationsProjects?: OrganizationsProjectDTO[] | null;
}

export class OrganizationBasicDTO implements IOrganizationBasicDTO {
    orgID?: number | null;
    orgArName!: string;
    orgEnName!: string;
    landLineNumber?: string | null;
    pepoleTBLs?: PepoleTBLDTO[] | null;

    constructor(data?: IOrganizationBasicDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.orgID = data["OrgID"] !== undefined ? data["OrgID"] : <any>null;
            this.orgArName = data["OrgArName"] !== undefined ? data["OrgArName"] : <any>null;
            this.orgEnName = data["OrgEnName"] !== undefined ? data["OrgEnName"] : <any>null;
            this.landLineNumber = data["LandLineNumber"] !== undefined ? data["LandLineNumber"] : <any>null;
            if (data["PepoleTBLs"] && data["PepoleTBLs"].constructor === Array) {
                this.pepoleTBLs = [] as any;
                for (let item of data["PepoleTBLs"])
                    this.pepoleTBLs!.push(PepoleTBLDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OrganizationBasicDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrganizationBasicDTO>(data, _mappings, OrganizationBasicDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrgID"] = this.orgID !== undefined ? this.orgID : <any>null;
        data["OrgArName"] = this.orgArName !== undefined ? this.orgArName : <any>null;
        data["OrgEnName"] = this.orgEnName !== undefined ? this.orgEnName : <any>null;
        data["LandLineNumber"] = this.landLineNumber !== undefined ? this.landLineNumber : <any>null;
        if (this.pepoleTBLs && this.pepoleTBLs.constructor === Array) {
            data["PepoleTBLs"] = [];
            for (let item of this.pepoleTBLs)
                data["PepoleTBLs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationBasicDTO {
    orgID?: number | null;
    orgArName: string;
    orgEnName: string;
    landLineNumber?: string | null;
    pepoleTBLs?: PepoleTBLDTO[] | null;
}

export class PositionInProjectDTO implements IPositionInProjectDTO {
    iD?: number | null;
    arName!: string;
    enName!: string;
    projectEmployees?: ProjectEmployeeDTO[] | null;

    constructor(data?: IPositionInProjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            if (data["ProjectEmployees"] && data["ProjectEmployees"].constructor === Array) {
                this.projectEmployees = [] as any;
                for (let item of data["ProjectEmployees"])
                    this.projectEmployees!.push(ProjectEmployeeDTO.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): PositionInProjectDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<PositionInProjectDTO>(data, _mappings, PositionInProjectDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        if (this.projectEmployees && this.projectEmployees.constructor === Array) {
            data["ProjectEmployees"] = [];
            for (let item of this.projectEmployees)
                data["ProjectEmployees"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPositionInProjectDTO {
    iD?: number | null;
    arName: string;
    enName: string;
    projectEmployees?: ProjectEmployeeDTO[] | null;
}

export class ProiertyTypeDTO implements IProiertyTypeDTO {
    iD?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: IProiertyTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ProiertyTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProiertyTypeDTO>(data, _mappings, ProiertyTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IProiertyTypeDTO {
    iD?: number | null;
    arName: string;
    enName: string;
}

export class ProjectDTO implements IProjectDTO {
    projectID?: number | null;
    projectNumber!: string;
    arName!: string;
    enName!: string;
    startDate!: Date;
    mainContractAmount!: number;
    endDate!: Date;
    isActiveProject!: boolean;

    constructor(data?: IProjectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.projectID = data["ProjectID"] !== undefined ? data["ProjectID"] : <any>null;
            this.projectNumber = data["ProjectNumber"] !== undefined ? data["ProjectNumber"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.mainContractAmount = data["MainContractAmount"] !== undefined ? data["MainContractAmount"] : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.isActiveProject = data["IsActiveProject"] !== undefined ? data["IsActiveProject"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ProjectDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<ProjectDTO>(data, _mappings, ProjectDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectID"] = this.projectID !== undefined ? this.projectID : <any>null;
        data["ProjectNumber"] = this.projectNumber !== undefined ? this.projectNumber : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["MainContractAmount"] = this.mainContractAmount !== undefined ? this.mainContractAmount : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["IsActiveProject"] = this.isActiveProject !== undefined ? this.isActiveProject : <any>null;
        return data; 
    }
}

export interface IProjectDTO {
    projectID?: number | null;
    projectNumber: string;
    arName: string;
    enName: string;
    startDate: Date;
    mainContractAmount: number;
    endDate: Date;
    isActiveProject: boolean;
}

export class RoleInTaskDTO implements IRoleInTaskDTO {
    iD?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: IRoleInTaskDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RoleInTaskDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<RoleInTaskDTO>(data, _mappings, RoleInTaskDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface IRoleInTaskDTO {
    iD?: number | null;
    arName: string;
    enName: string;
}

export class TaskOperationDTO implements ITaskOperationDTO {
    taskID?: number | null;
    taskName!: string;
    creatorEmp!: number;
    creationDate!: Date;
    startDate!: Date;
    endDate!: Date;
    parentID!: number;
    deliverableID!: number;
    taskStatus!: boolean;
    taskType!: number;
    taskProierty!: number;
    attachments!: string;

    constructor(data?: ITaskOperationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.taskID = data["TaskID"] !== undefined ? data["TaskID"] : <any>null;
            this.taskName = data["TaskName"] !== undefined ? data["TaskName"] : <any>null;
            this.creatorEmp = data["CreatorEmp"] !== undefined ? data["CreatorEmp"] : <any>null;
            this.creationDate = data["CreationDate"] ? new Date(data["CreationDate"].toString()) : <any>null;
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>null;
            this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>null;
            this.parentID = data["ParentID"] !== undefined ? data["ParentID"] : <any>null;
            this.deliverableID = data["DeliverableID"] !== undefined ? data["DeliverableID"] : <any>null;
            this.taskStatus = data["TaskStatus"] !== undefined ? data["TaskStatus"] : <any>null;
            this.taskType = data["TaskType"] !== undefined ? data["TaskType"] : <any>null;
            this.taskProierty = data["TaskProierty"] !== undefined ? data["TaskProierty"] : <any>null;
            this.attachments = data["Attachments"] !== undefined ? data["Attachments"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TaskOperationDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<TaskOperationDTO>(data, _mappings, TaskOperationDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TaskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        data["TaskName"] = this.taskName !== undefined ? this.taskName : <any>null;
        data["CreatorEmp"] = this.creatorEmp !== undefined ? this.creatorEmp : <any>null;
        data["CreationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>null;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["ParentID"] = this.parentID !== undefined ? this.parentID : <any>null;
        data["DeliverableID"] = this.deliverableID !== undefined ? this.deliverableID : <any>null;
        data["TaskStatus"] = this.taskStatus !== undefined ? this.taskStatus : <any>null;
        data["TaskType"] = this.taskType !== undefined ? this.taskType : <any>null;
        data["TaskProierty"] = this.taskProierty !== undefined ? this.taskProierty : <any>null;
        data["Attachments"] = this.attachments !== undefined ? this.attachments : <any>null;
        return data; 
    }
}

export interface ITaskOperationDTO {
    taskID?: number | null;
    taskName: string;
    creatorEmp: number;
    creationDate: Date;
    startDate: Date;
    endDate: Date;
    parentID: number;
    deliverableID: number;
    taskStatus: boolean;
    taskType: number;
    taskProierty: number;
    attachments: string;
}

export class TaskTypeDTO implements ITaskTypeDTO {
    iD?: number | null;
    arName!: string;
    enName!: string;

    constructor(data?: ITaskTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.iD = data["ID"] !== undefined ? data["ID"] : <any>null;
            this.arName = data["ArName"] !== undefined ? data["ArName"] : <any>null;
            this.enName = data["EnName"] !== undefined ? data["EnName"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): TaskTypeDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<TaskTypeDTO>(data, _mappings, TaskTypeDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD !== undefined ? this.iD : <any>null;
        data["ArName"] = this.arName !== undefined ? this.arName : <any>null;
        data["EnName"] = this.enName !== undefined ? this.enName : <any>null;
        return data; 
    }
}

export interface ITaskTypeDTO {
    iD?: number | null;
    arName: string;
    enName: string;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;
        
    constructor(status: number, headers: { [key: string]: any; }, result: TResult) 
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new SwaggerException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}